{"version":3,"sources":["components/Node.js","components/ControlPanel.js","utils/PriorityQueue.js","utils/helperFunctions.js","algorithms/SearchAlgorithms/A_Star.js","algorithms/SearchAlgorithms/DijkstrasAlgorithm.js","algorithms/SearchAlgorithms/GreedyBestFirstSearch.js","algorithms/SearchAlgorithms/DepthFirstSearch.js","utils/Set.js","algorithms/SearchAlgorithms/BreadthFirstSearch.js","algorithms/MazeAlgorithms/BinaryTreeMaze.js","algorithms/MazeAlgorithms/RecursiveDivision.js","algorithms/MazeAlgorithms/RecursiveBacktracking.js","utils/helperFunctionsVisualizer.js","components/Visualizer.js","components/Navbar.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","this","row","column","start","end","wall","onMouseDown","onMouseUp","onClick","onMouseEnter","id","className","Component","ControlPanel","searchAlgo","mazeAlgo","visualizeAStar","visualizeMaze","visualizeDijkstras","visualizeDivMaze","visualizeGreedyBFS","visualizeTree","visualizeDFS","visualizeBFS","resetField","clearSearch","onChange","event","setState","target","value","PriorityQueue","values","val","priority","newNode","push","bubbleUp","idx","length","element","parentIdx","Math","floor","parent","min","pop","sinkDown","leftChildIdx","rightChildIdx","leftChild","rightChild","swap","getNeighbors","curr_node","graph","neighbors","rowSize","columnSize","setUpCostMap","startNode","cost","map","rowIndex","node","nodeIndex","location","G","Infinity","filterStartAndEndNode","wallList","newArr","index","equalityChecker","arr1","arr2","shuffleArray","a","i","j","random","AStar","endNode","prevNode","result","visitedNodes","queue","enqueue","costMap","H","F","dequeue","reverse","neighborList","ManhattenDistance","shortestPath","abs","Dijkstras","distanceMap","setUpDistances","shift","sum_distance","distances","GreedyBestFirstSearch","DepthFirstSearch","stack","previousNodes","visited","setUpVisitedMap","allNeighbors","neighborNode","path","Set","isEmpty","checkIfDublicate","array","BreadthFirstSearch","currentNode","elem","add","get","BinaryTreeMaze","forEach","chosenNeighbor","flipCoin","inBetweenNode","getInBetweenNode","neighborArray","RecursiveDivision","endX","endY","mazeDivision","isHorizontal","startX","startY","wallX","randomNum","gap","divideVertically","wallY","divideHorizontally","max","width","height","wallLength","RecursiveBacktracking","mazeList","dfs","unvisitedNeigh","getUnvisitedNeighbors","neighbor","getInBetweenNodes","neigh","col","unvisited","filter","undefined","createNode","isWall","isStart","isEnd","basecase","nodeSchema","document","getElementById","setStartNode","deleteStartNode","setEndNode","deleteEndNode","setWall","deleteWall","animateSearchProcess","setTimeout","currRow","currColumn","animateShortestPath","animateMaze","createWalledGraph","Field","rowsize","window","innerHeight","innerWidth","startNodeExits","endNodeExists","mouseIsClicked","newGraph","colSize","currentRow","createGraph","search","GreedyBFS","maze","runMaze","animateDivMaze","board","key","Navbar","href","App","Boolean","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.17cf007b.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\n/**\n * Creates a node as a square.\n */\nclass Node extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n  render() {\n    const {\n      row,\n      column,\n      start,\n      end,\n      wall,\n      onMouseDown,\n      onMouseUp,\n      onClick,\n      onMouseEnter,\n    } = this.props;\n    // Sets the css className of Node and check whether its start, end or normal colored\n    const className = () => {\n      if (start) return \"node-start\";\n      if (end) return \"node-end\";\n      if (wall && !end && !start) return \"node-wall\";\n      return \"node\";\n    };\n    return (\n      <div\n        id={[row, column]}\n        className={className()}\n        onMouseEnter={() => onMouseEnter()}\n        onMouseUp={() => onMouseUp()}\n        onMouseDown={() => onMouseDown()}\n        onClick={() => onClick()}\n      ></div>\n    );\n  }\n}\n\nexport default Node;\n","import React, { Component } from \"react\";\n// CSS\nimport \"./ControlPanel.css\";\n\nclass ControlPanel extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { searchAlgo: \"AStar\", mazeAlgo: \"RecursiveDivision\" };\n  }\n  render() {\n    const {\n      visualizeAStar,\n      visualizeMaze,\n      visualizeDijkstras,\n      visualizeDivMaze,\n      visualizeGreedyBFS,\n      visualizeTree,\n      visualizeDFS,\n      visualizeBFS,\n      resetField,\n      clearSearch,\n    } = this.props;\n    const handleSearchChange = (event) => {\n      this.setState({ searchAlgo: event.target.value });\n    };\n\n    const handleSearchClick = () => {\n      const { searchAlgo } = this.state;\n      if (searchAlgo === \"AStar\") return visualizeAStar();\n      if (searchAlgo === \"Dijkstras\") return visualizeDijkstras();\n      if (searchAlgo === \"GreedyBFS\") return visualizeGreedyBFS();\n      if (searchAlgo === \"DepthFirstSearch\") return visualizeDFS();\n      if (searchAlgo === \"BreadthFirstSearch\") return visualizeBFS();\n    };\n\n    const handeMazeChange = (event) => {\n      this.setState({ mazeAlgo: event.target.value });\n    };\n\n    const handleMazeClick = () => {\n      const { mazeAlgo } = this.state;\n      if (mazeAlgo === \"RecursiveDivision\") return visualizeDivMaze();\n      if (mazeAlgo === \"BinaryTreeMaze\") return visualizeTree();\n      if (mazeAlgo === \"RecursiveBacktracking\") return visualizeMaze();\n    };\n    return (\n      <div className=\"ControlPanel\">\n        <div className=\"search\">\n          <p>Search Algorithms</p>\n          <select onChange={handleSearchChange}>\n            <option value=\"AStar\">AStar</option>\n            <option value=\"Dijkstras\">Dijkstras</option>\n            <option value=\"GreedyBFS\">GreedyBFS</option>\n            <option value=\"DepthFirstSearch\">DepthFirstSearch</option>\n            <option value=\"BreadthFirstSearch\">BreadthFirstSearch</option>\n          </select>\n          <button onClick={handleSearchClick}>Search</button>\n        </div>\n        <div className=\"maze\">\n          <p>Maze Algorithms</p>\n          <select onChange={handeMazeChange}>\n            <option value=\"RecursiveDivision\">RecursiveDivision</option>\n            <option value=\"BinaryTreeMaze\">BinaryTreeMaze</option>\n            <option value=\"RecursiveBacktracking\">RecursiveBacktracking</option>\n          </select>\n          <button onClick={handleMazeClick}>Choose</button>\n        </div>\n        <div className=\"reset\">\n          <button onClick={() => resetField()}>Reset Field</button>\n          <button onClick={() => clearSearch()}>Clear Search</button>\n        </div>\n      </div>\n    );\n  }\n}\nexport default ControlPanel;\n","/**\n * A priority queue or min heap is a datastructure in an array which shuffles newly added\n * values based on their priority. Smaller numbers mean higher priority\n */\nclass PriorityQueue {\n  constructor() {\n    this.values = [];\n  }\n  /**\n   * @returns {Array}\n   */\n  get() {\n    return this.values;\n  }\n  /**\n   * Adds value to array.\n   * @param {Object} val Any object you want to store.\n   * @param {Number} priority Integer. Lower number means higher priority.\n   */\n  enqueue(val, priority) {\n    let newNode = new Node(val, priority);\n    this.values.push(newNode);\n    this.bubbleUp();\n  }\n  /**\n   * Restructures array.\n   */\n  bubbleUp() {\n    let idx = this.values.length - 1;\n    const element = this.values[idx];\n    while (idx > 0) {\n      let parentIdx = Math.floor((idx - 1) / 2);\n      let parent = this.values[parentIdx];\n      if (element.priority >= parent.priority) break;\n      this.values[parentIdx] = element;\n      this.values[idx] = parent;\n      idx = parentIdx;\n    }\n  }\n  /**\n   *\n   */\n  dequeue() {\n    const min = this.values[0];\n    const end = this.values.pop();\n    if (this.values.length > 0) {\n      this.values[0] = end;\n      this.sinkDown();\n    }\n    return min;\n  }\n  /**\n   *\n   */\n  sinkDown() {\n    let idx = 0;\n    const length = this.values.length;\n    const element = this.values[0];\n    while (true) {\n      let leftChildIdx = 2 * idx + 1;\n      let rightChildIdx = 2 * idx + 2;\n      let leftChild, rightChild;\n      let swap = null;\n\n      if (leftChildIdx < length) {\n        leftChild = this.values[leftChildIdx];\n        if (leftChild.priority < element.priority) {\n          swap = leftChildIdx;\n        }\n      }\n      if (rightChildIdx < length) {\n        rightChild = this.values[rightChildIdx];\n        if (\n          (swap === null && rightChild.priority < element.priority) ||\n          (swap !== null && rightChild.priority < leftChild.priority)\n        ) {\n          swap = rightChildIdx;\n        }\n      }\n      if (swap === null) break;\n      this.values[idx] = this.values[swap];\n      this.values[swap] = element;\n      idx = swap;\n    }\n  }\n}\n\nclass Node {\n  constructor(val, priority) {\n    this.val = val;\n    this.priority = priority;\n  }\n}\n\nexport { PriorityQueue, Node };\n","/**\n * Gets the values of the coordinates of neighboring nodes. Only top, right, bottom and left neighbors.\n * @param {Object} curr_node Current node object\n * @param {Array} graph 2D graph consisting of node objects\n * @returns Array of all the valid coordinates [row, column] of neighboring nodes in an array\n */\nexport const getNeighbors = (curr_node, graph) => {\n  // find neighboring nodes; current[0] = row; currentrow[1] = column\n  const neighbors = [];\n  const rowSize = graph.length - 1;\n  const columnSize = graph[0].length - 1;\n  //right neighbor\n  if (curr_node[1] < columnSize)\n    neighbors.push([curr_node[0], curr_node[1] + 1]);\n  //bottom neighbor\n  if (curr_node[0] < rowSize) neighbors.push([curr_node[0] + 1, curr_node[1]]);\n  //left neighbor\n  if (curr_node[1] > 0) neighbors.push([curr_node[0], curr_node[1] - 1]);\n  //top neighbor\n  if (curr_node[0] > 0) neighbors.push([curr_node[0] - 1, curr_node[1]]);\n  return neighbors;\n};\n\n/**\n * Hashmap for keeping track of the cost of a node to determine the shortest path.\n * The cost of a node is the distance of the node to the start\n * Start cost is 0 and every unvisited node positive Infinity\n * @param {Array} graph 2D graph consisting of node objects\n * @param {Array} queue Queue as an Array\n * @returns {Object} Whole grid in an javascript object. Keys are arrays [row, column] and values are objects\n */\nexport const setUpCostMap = (graph, startNode) => {\n  let cost = {};\n  graph.map((row, rowIndex) => {\n    // eslint-disable-next-line array-callback-return\n    return row.map((node, nodeIndex) => {\n      let location = [node.row, node.column];\n      if (node === startNode) {\n        cost[location] = { G: 0 };\n      } else {\n        cost[location] = { G: Infinity };\n      }\n    });\n  });\n  return cost;\n};\n\n/**\n * Simple function to filter the start and end nodes out of the wall\n * This is only for frontend purposes, so you dont overwrite start and end nodes will walls\n * @param {Array} wallList array of all wall nodes\n * @param {Array} start [row, column] coordinates of the start node\n * @param {Array} end [row, column] coordinates of the end node\n * @returns {Array} filtered array\n */\nexport const filterStartAndEndNode = (wallList, start, end) => {\n  if (!wallList || !start || !end) return false;\n  let newArr = [];\n  for (let index = 0; index < wallList.length; index++) {\n    const element = wallList[index];\n    if (!equalityChecker(start, element) && !equalityChecker(end, element)) {\n      newArr.push(element);\n    }\n  }\n  wallList = newArr;\n  return wallList;\n};\n\n/**\n * Compares two array with two values [val1, val2] and checks if their values are the same\n * @param {Array} arr1 Array with two values -> [3, 3]\n * @param {Array} arr2 Array with two values -> [3, 3]\n * @returns Boolean; If array values are same -> true else -> false\n */\nexport const equalityChecker = (arr1, arr2) => {\n  if (arr1[0] === arr2[0] && arr1[1] === arr2[1]) return true;\n  return false;\n};\n\n/**\n * Shuffles an array and returns shuffled array\n * @param {Array} a Any array\n * @returns shuffled array\n */\nexport const shuffleArray = (a) => {\n  for (let i = a.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [a[i], a[j]] = [a[j], a[i]];\n  }\n  return a;\n};\n\nexport const createGraph = () => {\n  const graph = [];\n  let rowSize = 21;\n  let colSize = 35;\n  // create a 2D Array\n  for (let row = 0; row < rowSize; row++) {\n    const currentRow = [];\n    for (let column = 0; column < colSize; column++) {\n      // create an object with node coordinates. Starts and end return a true bool when they hit the coordinates\n      currentRow.push(createNode(row, column));\n    }\n    graph.push(currentRow);\n  }\n  return graph;\n};\n\nexport const createNode = (row, column) => {\n  const nodeSchema = {\n    row: row,\n    column: column,\n    wall: false,\n    start: false,\n    end: false,\n  };\n  return nodeSchema;\n};\n","import { PriorityQueue } from \"../../utils/PriorityQueue.js\";\nimport {\n  getNeighbors,\n  setUpCostMap,\n  equalityChecker,\n} from \"../../utils/helperFunctions.js\";\n\n/**\n * The A-Star algorithm is an extension of dijkstras and return the shortest path between 2 nodes\n * It uses a score to determine the direction to travel\n * The formula is F = G + H.\n * G is the distance from the node to the start node.\n * H is based on the Manhatten distance\n * F is the sum of G and H.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass AStar {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  shortestPath() {\n    if (!this.graph || !this.startNode || !this.endNode) return false;\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n    let prevNode = { start: null };\n    const result = [];\n    const visitedNodes = [];\n    let queue = new PriorityQueue();\n    queue.enqueue(start, 0);\n    // setUp distances grid in a hashmap -> distanceMap[[0, 0]]\n    const costMap = setUpCostMap(this.graph, this.startNode);\n    costMap[start] = { G: 0, H: 0, F: 0 };\n    // while nodes to visit still exists\n    while (queue.values.length) {\n      //Get the enqueued array\n      let curr_node = queue.dequeue().val;\n      // if wall skip it and continue\n      if (this.graph[curr_node[0]][curr_node[1]].wall === true) continue;\n      // EndCondition: Check if current node is the end node -> finish\n      if (equalityChecker(curr_node, end)) {\n        // traverse the prevNode object to get all coordinates in an Array\n        while (prevNode[curr_node]) {\n          result.push(curr_node);\n          curr_node = prevNode[curr_node];\n        }\n        // Order the array from start to end node\n        result.reverse();\n        break;\n      }\n\n      if (curr_node) {\n        // gets an array of neighbors\n        let neighborList = getNeighbors(curr_node, this.graph);\n        for (let i = 0; i < neighborList.length; i++) {\n          // G: Similar to dijkstras its the distance between the current node and the start\n          const G = costMap[curr_node][\"G\"] + 1;\n          // H: The Heuristik. Manhatten distance\n          const H = this.ManhattenDistance(neighborList[i], end);\n          // F: New Score to determine shortest path\n          const F = G + H;\n          // important for shortest path. Avoids checking nodes twice and updates shortest path\n          if (G < costMap[neighborList[i]][\"G\"]) {\n            // Avoids overlapping visited nodes with walled nodes and filters end node for front end purposes\n            if (\n              !this.graph[neighborList[i][0]][neighborList[i][1]].wall &&\n              !equalityChecker(neighborList[i], end)\n            )\n              visitedNodes.push(neighborList[i]);\n            costMap[neighborList[i]] = { G: G };\n            prevNode[neighborList[i]] = curr_node;\n            queue.enqueue(neighborList[i], F);\n          }\n        }\n      }\n    }\n    return { shortestPath: result, visitedNodes: visitedNodes };\n  }\n\n  ManhattenDistance(node, end) {\n    return Math.abs(end[0] - node[0]) + Math.abs(end[1] - node[1]);\n  }\n}\n\nexport default AStar;\n","import { getNeighbors, equalityChecker } from \"../../utils/helperFunctions.js\";\n\n/**\n * Classic dijkstras is an algorithm for finding the shortest path between 2 nodes.\n * Usually you need a PriorityQueue/Heap data structure but the distant between nodes\n * is constant 1 so you can use a queue\n *\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass Dijkstras {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  shortestPath() {\n    if (!this.graph || !this.startNode || !this.endNode) return false;\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n    let prevNode = {};\n    let queue = [start];\n    const result = [];\n    const visitedNodes = [];\n    // setUp distances grid in a hashmap -> distanceMap[[0, 0]]\n    const distanceMap = this.setUpDistances(this.graph, this.startNode);\n\n    // while nodes to visit still exists\n    while (queue.length) {\n      let curr_node = queue.shift();\n      // if wall skip it and continue\n      if (this.graph[curr_node[0]][curr_node[1]].wall === true) continue;\n      // EndCondition: Check if current node is the end node -> finish\n      if (equalityChecker(curr_node, end)) {\n        // traverse the prevNode object to get all coordinates in an Array\n        while (prevNode[curr_node]) {\n          result.push(curr_node);\n          curr_node = prevNode[curr_node];\n        }\n        // Order the array from start to end node\n        result.reverse();\n        break;\n      }\n\n      if (curr_node) {\n        // removes first node for visual effect in frontend\n        if (curr_node !== start) visitedNodes.push(curr_node);\n        // gets an array of neighbors\n        let neighborList = getNeighbors(curr_node, this.graph);\n        for (let i = 0; i < neighborList.length; i++) {\n          // Determine the cost \"G\" of a node\n          // adds the distance of the current node with its neighbors which is always 1\n          let sum_distance = distanceMap[curr_node] + 1;\n          if (sum_distance < distanceMap[neighborList[i]]) {\n            prevNode[neighborList[i]] = curr_node;\n            distanceMap[neighborList[i]] = sum_distance;\n            queue.push(neighborList[i]);\n          }\n        }\n      }\n    }\n    return { shortestPath: result, visitedNodes: visitedNodes };\n  }\n\n  /**\n   * Based on graph, put every node into an javascript object as a key and set their value\n   * to Infinity and the start to 0\n   * @param {Array} graph 2D graph consisting of node objects\n   * @param {Array} queue Queue as an Array\n   */\n  setUpDistances(graph, startNode) {\n    let distances = {};\n    graph.map((row, rowIndex) => {\n      // eslint-disable-next-line array-callback-return\n      return row.map((node, nodeIndex) => {\n        let location = [node.row, node.column];\n        if (node === startNode) {\n          distances[location] = 0;\n        } else {\n          distances[location] = Infinity;\n        }\n      });\n    });\n    return distances;\n  }\n}\n\nexport default Dijkstras;\n","import { PriorityQueue } from \"../../utils/PriorityQueue.js\";\nimport {\n  getNeighbors,\n  setUpCostMap,\n  equalityChecker,\n} from \"../../utils/helperFunctions.js\";\n\n/**\n * The Greedy Best-First-Search determines the shortest path between 2 nodes\n * It uses a score to determine the direction to travel\n * The formula is F = G + H.\n * G is the distance from the node to the start node.\n * H is based on the Pythagorean theorem.\n * F is the sum of G and H.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass GreedyBestFirstSearch {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  shortestPath() {\n    if (!this.graph || !this.startNode || !this.endNode) return false;\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n    let prevNode = { start: null };\n    const result = [];\n    const visitedNodes = [];\n    let queue = new PriorityQueue();\n    queue.enqueue(start, 0);\n    // setUp distances grid in a hashmap -> distanceMap[[0, 0]]\n    const costMap = setUpCostMap(this.graph, this.startNode);\n    costMap[start] = { G: 0, H: 0, F: 0 };\n    // while nodes to visit still exists\n    while (queue.values.length) {\n      //Get the enqueued array\n      let curr_node = queue.dequeue().val;\n      // if wall skip it and continue\n      if (this.graph[curr_node[0]][curr_node[1]].wall === true) continue;\n      // EndCondition: Check if current node is the end node -> finish\n      if (equalityChecker(curr_node, end)) {\n        // traverse the prevNode object to get all coordinates in an Array\n        while (prevNode[curr_node]) {\n          result.push(curr_node);\n          curr_node = prevNode[curr_node];\n        }\n        // Order the array from start to end node\n        result.reverse();\n        break;\n      }\n\n      if (curr_node) {\n        // gets an array of neighbors\n        let neighborList = getNeighbors(curr_node, this.graph);\n        for (let i = 0; i < neighborList.length; i++) {\n          // G: Similar to dijkstras its the distance between the current node and the start\n          const G = costMap[curr_node][\"G\"] + 1;\n          // H: The Heuristik. Pythagorean theorem\n          const H =\n            (neighborList[i][0] - end[0]) ** 2 +\n            (neighborList[i][1] - end[1]) ** 2;\n\n          // F: New Score to determine shortest path\n          const F = G + H;\n          // important for shortest path. Avoids checking nodes twice and updates shortest path\n          if (G < costMap[neighborList[i]][\"G\"]) {\n            // Avoids overlapping visited nodes with walled nodes and filters end node for front end purposes\n            if (\n              !this.graph[neighborList[i][0]][neighborList[i][1]].wall &&\n              !equalityChecker(neighborList[i], end)\n            )\n              visitedNodes.push(neighborList[i]);\n            costMap[neighborList[i]] = { G: G };\n            prevNode[neighborList[i]] = curr_node;\n            queue.enqueue(neighborList[i], F);\n          }\n        }\n      }\n    }\n    return { shortestPath: result, visitedNodes: visitedNodes };\n  }\n}\n\nexport default GreedyBestFirstSearch;\n","import { equalityChecker, getNeighbors } from \"../../utils/helperFunctions.js\";\n/**\n * The depth-first-search is a classic algorithm for traveling trees or graphs.\n * Its not a good algorithm for pathfinding and rarely delivers the shortest path.\n * The algorithm itself is done iteratly with a stack data structure.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass DepthFirstSearch {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  search() {\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n    const result = [];\n    const visitedNodes = [];\n    const stack = [start];\n    const previousNodes = {};\n    const visited = this.setUpVisitedMap(this.graph, this.startNode);\n\n    while (stack.length > 0) {\n      let curr_node = stack.pop();\n      visited[curr_node] = true;\n      //Found the node\n      if (equalityChecker(curr_node, end)) {\n        // traverse the prevNode object to get all coordinates in an Array\n        while (previousNodes[curr_node]) {\n          result.push(curr_node);\n          curr_node = previousNodes[curr_node];\n        }\n        // Order the array from start to end node\n        result.reverse();\n        break;\n      }\n      // if its a wall => skip\n      if (this.graph[curr_node[0]][curr_node[1]].wall === true) continue;\n      // get all neighbors of the current node\n      const allNeighbors = getNeighbors(curr_node, this.graph);\n      for (let i = 0; i < allNeighbors.length; i++) {\n        const neighborNode = allNeighbors[i];\n        // check if node wasnt visited otherwise ignore it\n        if (!visited[neighborNode]) {\n          // put the unvisited node on the stack for backtracking\n          stack.push(neighborNode);\n          previousNodes[neighborNode] = curr_node;\n          // for frontend purposes: Check if neighbors arent walls or endNode\n          if (\n            !this.graph[neighborNode[0]][neighborNode[1]].wall &&\n            !equalityChecker(neighborNode, end)\n          )\n            visitedNodes.push(neighborNode);\n        }\n      }\n    }\n    return { path: result, visitedNodes: visitedNodes };\n  }\n\n  setUpVisitedMap(graph, startNode) {\n    const visited = {};\n    graph.map((row, rowIndex) => {\n      // eslint-disable-next-line array-callback-return\n      return row.map((node, nodeIndex) => {\n        let location = [node.row, node.column];\n        visited[location] = false;\n      });\n    });\n    return visited;\n  }\n}\n\nexport default DepthFirstSearch;\n","class Set {\n  constructor() {\n    this.values = [];\n  }\n\n  get() {\n    return this.values;\n  }\n\n  isEmpty() {\n    if (this.values.length === 0) return true;\n    return false;\n  }\n\n  add(value) {\n    if (this.isEmpty()) return this.values.push(value);\n    if (!checkIfDublicate(value, this.values)) return this.values.push(value);\n  }\n\n  has(value) {\n    return checkIfDublicate(value, this.values);\n  }\n}\n\nexport default Set;\n\n/**\n * Compares two array with two values [val1, val2] and checks if their values are the same\n * @param {Array} arr1 Array with two values -> [3, 3]\n * @param {Array} arr2 Array with two values -> [3, 3]\n * @returns Boolean; If array values are same -> true else -> false\n */\nconst equalityChecker = (arr1, arr2) => {\n  if (arr1[0] === arr2[0] && arr1[1] === arr2[1]) return true;\n  return false;\n};\n\n/**\n * Checks if there is a dublicate value in an array\n * @param {Array} value single array [val1, val2]\n * @param {Array} array values in the set\n */\nconst checkIfDublicate = (value, array) => {\n  for (let i = 0; i < array.length; i++) {\n    const element = array[i];\n    if (equalityChecker(element, value)) return true;\n  }\n  return false;\n};\n","import { equalityChecker, getNeighbors } from \"../../utils/helperFunctions.js\";\nimport Set from \"../../utils/Set.js\";\n/**\n * The breadth-first-search is a classic tree or graph traversal algorithm.\n * It is an uninformed algorithm which guarantees the shortest path.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass BreadthFirstSearch {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  search() {\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n    const result = [];\n    const visitedNodes = new Set();\n    const queue = [start];\n    const previousNodes = {};\n    const visited = this.setUpVisitedMap(this.graph, this.startNode);\n\n    while (queue.length > 0) {\n      let currentNode = queue.shift();\n      // set the startnode to visited\n      if (equalityChecker(currentNode, start)) visited[currentNode] = true;\n      // if wall current node is a wall => skip node\n      if (this.graph[currentNode[0]][currentNode[1]].wall === true) continue;\n      // end condition\n      if (equalityChecker(currentNode, end)) {\n        // traverse the prevNode object to get all coordinates in an Array\n        while (previousNodes[currentNode]) {\n          result.push(currentNode);\n          currentNode = previousNodes[currentNode];\n        }\n        // Order the array from start to end node\n        result.reverse();\n        break;\n      }\n      // get neighbors of the current node\n      const neighbors = getNeighbors(currentNode, this.graph);\n      for (let i = 0; i < neighbors.length; i++) {\n        const elem = neighbors[i];\n        if (!visited[elem]) {\n          visited[elem] = true;\n          queue.push(elem);\n          previousNodes[elem] = currentNode;\n          if (!equalityChecker(currentNode, start))\n            visitedNodes.add(currentNode);\n        }\n      }\n    }\n    return { path: result, visitedNodes: visitedNodes.get() };\n  }\n\n  setUpVisitedMap(graph, startNode) {\n    const visited = {};\n    graph.map((row, rowIndex) => {\n      // eslint-disable-next-line array-callback-return\n      return row.map((node, nodeIndex) => {\n        let location = [node.row, node.column];\n        visited[location] = false;\n      });\n    });\n    return visited;\n  }\n}\n\nexport default BreadthFirstSearch;\n","import {\n  shuffleArray,\n  filterStartAndEndNode,\n} from \"../../utils/helperFunctions.js\";\nimport Set from \"../../utils/Set.js\";\n\n/**\n * This algorithm is based on the binary tree data structure.\n * Like the binary tree every branch has to children.\n * There will never be a crossroads, and all dead ends have passages pointing down or right,\n * and never up or left.\n * Two of the four sides will form a corridor where no wall can exists.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass BinaryTreeMaze {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  runMaze() {\n    // we need a Set data structure to prevnt dublicate entries\n    const result = new Set();\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n\n    // iterate through the graph\n    this.graph.forEach((row, rowIndex) => {\n      row.forEach((node, nodeIndex) => {\n        // because of the grid design of the app, always skip a row to form the wall nodes\n        // horitontal / vertical walls are always on even rows and columns\n        if (rowIndex % 2 === 0 && nodeIndex % 2 === 0) {\n          const allNeighbors = this.getNeighbors(rowIndex, nodeIndex);\n          if (allNeighbors) {\n            const { currentNode, neighbors } = allNeighbors;\n            const chosenNeighbor = this.flipCoin(neighbors);\n            const inBetweenNode = this.getInBetweenNode(\n              currentNode,\n              chosenNeighbor\n            );\n            result.add(chosenNeighbor);\n            result.add(inBetweenNode);\n            result.add(currentNode);\n          }\n        }\n      });\n    });\n    return filterStartAndEndNode(result.get(), start, end);\n  }\n\n  /**\n   * Get north or west neighbors of the current node.\n   * Must travel 2 nodes [2, 2] => west neighbor [2,0] because of the grid design\n   * @param {Int} row row number of the current node\n   * @param {Int} column column number of the current node\n   * @returns {Object} {currentNode: [currentNode-row, currentNode-column], neighbots: [All neighbors as arrays]}\n   */\n  getNeighbors(row, column) {\n    let neighbors = [];\n    // north\n    if (row >= 2) neighbors.push([row - 2, column]);\n    // west\n    if (column >= 2) neighbors.push([row, column - 2]);\n    // skip node which has no north or west neighbors\n    if (neighbors.length === 0) return;\n    return { currentNode: [row, column], neighbors: neighbors };\n  }\n  /**\n   * Shuffles an array and returns first value of shuffled array to get a random neighbor\n   * @param {Array} neighborArray Array of all neighbors\n   * @returns {Array} returns one array of the row and column data of the neighbor node\n   */\n  flipCoin(neighborArray) {\n    if (neighborArray.length === 1) return neighborArray[0];\n    return shuffleArray(neighborArray)[0];\n  }\n  /**\n   * We travel 2 nodes at the same time. If we set the current node and the neighbor node to\n   * passable nodes we need to make the in between node of both to a passable node too.\n   * @param {Array} currentNode coordinates of the current node\n   * @param {Array} neighborNode coordinates of the neighbor node\n   * @returns {Array}\n   */\n  getInBetweenNode(currentNode, neighborNode) {\n    const row = currentNode[0] - neighborNode[0];\n    const column = currentNode[1] - neighborNode[1];\n    // get north in between node\n    if (row !== 0) return [currentNode[0] - 1, currentNode[1]];\n    // get west in between node\n    if (column !== 0) return [currentNode[0], currentNode[1] - 1];\n  }\n}\n\nexport default BinaryTreeMaze;\n","import { filterStartAndEndNode } from \"../../utils/helperFunctions.js\";\n/**\n * The recursive divison is an algorithm which splits a grid either horizontal or vertical.\n * You have to determine a random coordinate and draw the wall.\n * The wall has to have a randomly generated gap.\n * By dividing the grid you create subgrids which have to be divided and walled again\n * Therefore you need to call 4 recursions: If split vertically left and right, otherwise if split horizontal top and bottom.\n * The recursive function stops when the difference between end and start coordinates is 1.\n *\n * It is important to notice that the walls must have 1 passable node in between each other.\n * At the coordinate of the gap cannot be a wall.\n * The most sensitive part of this algorithm is in generating random values for gap and walls.\n *\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\n\nexport class RecursiveDivision {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n  // executes the maze\n  runMaze() {\n    let wallList = [];\n    const startX = 0;\n    const startY = 0;\n    const endX = this.graph[0].length - 1;\n    const endY = this.graph.length - 1;\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n    // fill wallList with Arrays of coordinates -> [row, column]\n    this.mazeDivision(\n      startX,\n      startY,\n      endX,\n      endY,\n      this.isHorizontal(),\n      wallList\n    );\n    // filter the newly filled wallList. This is optional for the frontend, so you dont wall a start or end node\n    wallList = filterStartAndEndNode(wallList, start, end);\n    return wallList;\n  }\n\n  mazeDivision(startX, startY, endX, endY, isHorizontal, wallList) {\n    if (!isHorizontal) {\n      if (endX - startX < 2) {\n        return;\n      }\n      // generate the random x coordinate for the wall\n      let wallX = Math.floor(this.randomNum(startX + 1, endX) / 2) * 2;\n      // generate the random x coordinate for the gap\n      let gap =\n        Math.floor(Math.floor(Math.random() * (endY - startY) + startY) / 2) *\n          2 +\n        1;\n      // set up vertical walls based on wall x and gap\n      this.divideVertically(startY, wallX, endY, gap, wallList);\n\n      this.mazeDivision(\n        startX,\n        startY,\n        wallX - 1,\n        endY,\n        this.isHorizontal(wallX - 1 - startX, endY - startY),\n        wallList\n      );\n\n      this.mazeDivision(\n        wallX + 1,\n        startY,\n        endX,\n        endY,\n        this.isHorizontal(endX - (wallX + 1), endY - startY),\n        wallList\n      );\n    }\n\n    if (isHorizontal) {\n      if (endY - startY < 2) {\n        return;\n      }\n      // generate the random x coordinate for the wall\n      let wallY = Math.floor(this.randomNum(startY + 1, endY) / 2) * 2;\n      // generate the random x coordinate for the gap\n      let gap =\n        Math.floor(Math.floor(Math.random() * (endX - startX) + startX) / 2) *\n          2 +\n        1;\n      // set up vertical walls based on wall x and gap\n      this.divideHorizontally(startX, wallY, endX, gap, wallList);\n\n      this.mazeDivision(\n        startX,\n        startY,\n        endX,\n        wallY - 1,\n        this.isHorizontal(endX - startX, wallY - 1 - startY),\n        wallList\n      );\n      this.mazeDivision(\n        startX,\n        wallY + 1,\n        endX,\n        endY,\n        this.isHorizontal(endX - startX, endY - (wallY + 1)),\n        wallList\n      );\n    }\n  }\n  /**\n   * Gets a random int value in range of min and max\n   * @param {int} min smaller value\n   * @param {int} max higher value\n   * @returns random value\n   */\n  randomNum(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  }\n\n  /**\n   * Checks if we have to divide the grid vertically or horizontally\n   * @param {Int} width width of the current grid\n   * @param {Int} height height of the current grid\n   * @returns {Boolean} horizontal or not\n   */\n  isHorizontal(width, height) {\n    if (width < height) {\n      return true;\n    } else if (height < width) {\n      return false;\n    } else {\n      // makes the maze more dynamic\n      return Math.random() < 0.5 ? true : false;\n    }\n  }\n\n  /**\n   * Sets up walls\n   * @param {Int} startY start value of Y coordinate\n   * @param {Int} wallX random generated coordinate of the wall\n   * @param {Int} wallLength height of the grid\n   * @param {Int} gap random generated coordinated of the gap\n   * @param {Array} wallList array of wall coordinates\n   */\n  divideVertically(startY, wallX, wallLength, gap, wallList) {\n    for (let wallY = startY; wallY <= wallLength; wallY++) {\n      if (wallY !== gap) {\n        wallList.push([wallY, wallX]);\n      }\n    }\n  }\n  /**\n   * Sets up walls\n   * @param {Int} startX start value of X coordinate\n   * @param {Int} wallY random generated coordinate of the wall\n   * @param {Int} wallLength height of the grid\n   * @param {Int} gap random generated coordinated of the gap\n   * @param {Array} wallList array of wall coordinates\n   */\n  divideHorizontally(startX, wallY, wallLength, gap, wallList) {\n    for (let wallX = startX; wallX <= wallLength; wallX++) {\n      if (wallX !== gap) {\n        wallList.push([wallY, wallX]);\n      }\n    }\n  }\n}\n\nexport default RecursiveDivision;\n","import { shuffleArray } from \"../../utils/helperFunctions.js\";\n\n/**\n * This algortihm uses a depth-first-search algorithm to traverse the graph.\n * A stack is used to keep track of the visited node and ensures the ability to backtrack if you hit a dead end.\n * The frontend graph looks like a chessboard so you have to traverse 2 nodes at the same time\n * to generate walls and passable nodes.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass RecursiveBacktracking {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  // executes the recursive backtraking algorithm\n  runMaze() {\n    const start = [this.startNode.row, this.startNode.column];\n    const stack = [start];\n    const visited = {};\n    const mazeList = [];\n    this.dfs(stack, visited, mazeList);\n    // removes first and last for frontend purposes\n    mazeList.shift();\n    mazeList.pop();\n    return mazeList;\n  }\n\n  // depth-first-search algorithm to traverse the graph\n  dfs(stack, visited, mazeList) {\n    // pop current Node in the stack\n    const currentNode = stack.pop();\n    // Will become a wall node\n    mazeList.push(currentNode);\n    // node is visited!\n    visited[currentNode] = true;\n    // TODO: traverse 2 node at the same time -> [0, 0] neighbor are [0, 2] or [2, 0]\n    // get all neighbors which werent visited yet\n    const unvisitedNeigh = this.getUnvisitedNeighbors(currentNode, visited);\n    // hit a dead end -> backtrack!\n    if (unvisitedNeigh.length === 0) {\n      // no value in stack -> dfs is finished\n      if (stack.length === 0) return;\n      // else perform dfs with the node on top of the stack (backtrack)\n      return this.dfs(stack, visited, mazeList);\n    }\n    // has valid neighbors -> put back to stack to backtrack\n    stack.push(currentNode);\n    // get a random unvisited neighbor\n    const neighbor = shuffleArray(unvisitedNeigh).pop();\n    // Remember: We traverse 2 node at the same time -> get in between node\n    const inBetweenNode = this.getInBetweenNodes(currentNode, neighbor);\n    visited[inBetweenNode] = true;\n    mazeList.push(inBetweenNode);\n    // we traversed 2 nodes and set the current location as next node -> recursion with current node\n    stack.push(neighbor);\n    this.dfs(stack, visited, mazeList);\n  }\n\n  /**\n   * We traverse 2 nodes at the same time. Get the in between node\n   * @param {Array} currentNode current location of the node\n   * @param {Array} neigh neighbor node of the current node\n   * @returns {Array} location of the in between node\n   */\n  getInBetweenNodes(currentNode, neigh) {\n    const row = (neigh[0] - currentNode[0]) / 2;\n    const col = (neigh[1] - currentNode[1]) / 2;\n    const inBetweenNode = [currentNode[0] + row, currentNode[1] + col];\n    return inBetweenNode;\n  }\n\n  /**\n   * Gets all unvisited neighbors of current node\n   * @param {Array} currentNode current location of the node\n   * @param {Object} visited Obj which checks if nodes are true (has been visited)\n   * @returns {Array} filtered array of all unvisited nodes\n   */\n  getUnvisitedNeighbors(currentNode, visited) {\n    const rowSize = this.graph.length - 2;\n    const columnSize = this.graph[0].length - 2;\n    const row = currentNode[0];\n    const column = currentNode[1];\n    const unvisited = [];\n    // right\n    if (column < columnSize) {\n      unvisited.push([row, column + 2]);\n    }\n    // bottom\n    if (row < rowSize) {\n      unvisited.push([row + 2, column]);\n    }\n    // left\n    if (column > 1) {\n      unvisited.push([row, column - 2]);\n    }\n    // top\n    if (row > 1) {\n      unvisited.push([row - 2, column]);\n    }\n    return unvisited.filter((i) => {\n      return visited[i] === undefined;\n    });\n  }\n}\n\nexport default RecursiveBacktracking;\n","export const createGraph = (\n  rowSize,\n  colSize,\n  isWall,\n  isStart,\n  isEnd,\n  basecase\n) => {\n  const graph = [];\n  // create a 2D Array\n  for (let row = 0; row < rowSize; row++) {\n    const currentRow = [];\n    for (let column = 0; column < colSize; column++) {\n      // create an object with node coordinates. Starts and end return a true bool when they hit the coordinates\n      currentRow.push(\n        createNode(row, column, isWall, isStart, isEnd, basecase)\n      );\n    }\n    graph.push(currentRow);\n  }\n  return graph;\n};\n\nexport const createNode = (row, column, isWall, isStart, isEnd, basecase) => {\n  const nodeSchema = {\n    row: row,\n    column: column,\n    wall: isWall,\n    start: isStart,\n    end: isEnd,\n  };\n  if (basecase === \"resetAll\")\n    document.getElementById([row, column]).className = \"node\";\n\n  return nodeSchema;\n};\n\nexport const setStartNode = (graph, row, column) => {\n  graph[row][column].start = true;\n};\n\nexport const deleteStartNode = (graph, row, column) => {\n  if (graph[row][column]) {\n    graph[row][column].start = false;\n  }\n};\n\nexport const setEndNode = (graph, row, column) => {\n  graph[row][column].end = true;\n};\n\nexport const deleteEndNode = (graph, row, column) => {\n  graph[row][column].end = false;\n};\n\nexport const setWall = (graph, row, column) => {\n  graph[row][column].wall = true;\n  return graph;\n};\n\nexport const deleteWall = (graph, row, column) => {\n  graph[row][column].wall = false;\n  return graph;\n};\n\nexport const animateSearchProcess = (neighborList, shortestPath) => {\n  for (let i = 0; i < neighborList.length; i++) {\n    setTimeout(() => {\n      let currRow = neighborList[i][0];\n      let currColumn = neighborList[i][1];\n      document.getElementById([currRow, currColumn]).className = \"node-search\";\n      if (i === neighborList.length - 1) {\n        return setTimeout(() => {\n          animateShortestPath(shortestPath);\n        }, 150);\n      }\n    }, 30 * i);\n  }\n};\n\nexport const animateShortestPath = (shortestPath) => {\n  for (let i = 0; i < shortestPath.length - 1; i++) {\n    setTimeout(() => {\n      let currRow = shortestPath[i][0];\n      let currColumn = shortestPath[i][1];\n      document.getElementById([currRow, currColumn]).className =\n        \"node-shortest-path\";\n    }, 60 * i);\n  }\n  return;\n};\n\nexport const animateMaze = (wallList, graph, endNode) => {\n  // i = 1 so we dont animate start node\n  for (let i = 0; i < wallList.length; i++) {\n    setTimeout(() => {\n      const currRow = wallList[i][0];\n      const currColumn = wallList[i][1];\n      if (currRow !== endNode.row || currColumn !== endNode.column) {\n        deleteWall(graph, currRow, currColumn);\n        document.getElementById([currRow, currColumn]).className = \"node\";\n      }\n    }, 30 * i);\n  }\n};\n\nexport const animateDivMaze = (wallList, graph) => {\n  // i = 1 so we dont animate start node\n  for (let i = 0; i < wallList.length; i++) {\n    setTimeout(() => {\n      const currRow = wallList[i][0];\n      const currColumn = wallList[i][1];\n      setWall(graph, currRow, currColumn);\n      document.getElementById([currRow, currColumn]).className = \"node-wall\";\n    }, 30 * i);\n  }\n};\n\nexport const createWalledGraph = (graph, startNode, endNode) => {\n  setTimeout(() => {\n    graph.forEach((row, rowIndex) => {\n      return row.forEach((node, nodeIndex) => {\n        const currentNode = graph[rowIndex][nodeIndex];\n        if (!currentNode.start && !currentNode.end) {\n          setWall(graph, rowIndex, nodeIndex);\n          document.getElementById([rowIndex, nodeIndex]).className =\n            \"node-wall\";\n        }\n      });\n    });\n  });\n};\n","import React, { Component } from \"react\";\n// Components\nimport Node from \"./Node.js\";\nimport ControlPanel from \"./ControlPanel.js\";\n// CSS\nimport \"./Visualizer.css\";\n// Search Algorithms\nimport AStar from \"../algorithms/SearchAlgorithms/A_Star.js\";\nimport Dijkstras from \"../algorithms/SearchAlgorithms/DijkstrasAlgorithm.js\";\nimport GreedyBFS from \"../algorithms/SearchAlgorithms/GreedyBestFirstSearch\";\nimport DepthFirstSearch from \"../algorithms/SearchAlgorithms/DepthFirstSearch.js\";\nimport BreadthFirstSearch from \"../algorithms/SearchAlgorithms/BreadthFirstSearch.js\";\n// Maze Algorithms\nimport BinaryTreeMaze from \"../algorithms/MazeAlgorithms/BinaryTreeMaze.js\";\nimport RecursiveDivision from \"../algorithms/MazeAlgorithms/RecursiveDivision.js\";\nimport RecursiveBacktracking from \"../algorithms/MazeAlgorithms/RecursiveBacktracking.js\";\n// helper functions\nimport {\n  createGraph,\n  setEndNode,\n  setStartNode,\n  setWall,\n  deleteWall,\n  deleteEndNode,\n  deleteStartNode,\n  animateDivMaze,\n  animateSearchProcess,\n  animateMaze,\n  createWalledGraph,\n} from \"../utils/helperFunctionsVisualizer.js\";\n\nclass Field extends Component {\n  // graph size\n  rowsize = Math.floor(Math.floor((window.innerHeight - 130) / 25) * 0.9);\n  columnSize = Math.floor(Math.floor(window.innerWidth / 25) * 0.9);\n\n  state = {\n    graph: [],\n    startNodeExits: false,\n    endNodeExists: false,\n    mouseIsClicked: false,\n    startNode: null,\n    endNode: null,\n  };\n\n  // set up field\n  componentDidMount() {\n    const newGraph = createGraph(\n      this.rowsize,\n      this.columnSize,\n      false,\n      false,\n      false\n    );\n    this.setState({ graph: newGraph });\n  }\n\n  onClick = (row, column) => {\n    const { startNodeExits, endNodeExists, graph } = this.state;\n    const { start, end } = graph[row][column];\n\n    // set start node\n    if (!startNodeExits) {\n      setStartNode(graph, row, column);\n      this.setState({ startNodeExits: true, startNode: graph[row][column] });\n    }\n    // delete start node\n    if (startNodeExits && start) {\n      deleteStartNode(graph, row, column);\n      this.setState({ startNodeExits: false, startNode: null });\n    }\n    // set end node\n    if (!endNodeExists && startNodeExits && !start) {\n      setEndNode(graph, row, column);\n      this.setState({ endNodeExists: true, endNode: graph[row][column] });\n    }\n    // delete end node\n    if (endNodeExists && setStartNode && end && !start) {\n      deleteEndNode(graph, row, column);\n      this.setState({ endNodeExists: false, endNode: null });\n    }\n  };\n\n  // on mouse down set up or delete a wall\n  onMouseDown = (row, column) => {\n    const { startNodeExits, endNodeExists, graph, mouseIsClicked } = this.state;\n    const { start, end, wall } = graph[row][column];\n    // if node isnt a wall -> setup the wall\n    if (\n      endNodeExists &&\n      startNodeExits &&\n      !mouseIsClicked &&\n      !end &&\n      !start &&\n      !wall\n    ) {\n      let newGraph = setWall(graph, row, column);\n      this.setState({ graph: newGraph, mouseIsClicked: true });\n    }\n    // if node is a wall -> delete wall\n    if (endNodeExists && startNodeExits && !end && !start && wall) {\n      let newGraph = deleteWall(graph, row, column);\n      this.setState({ graph: newGraph });\n    }\n  };\n\n  onMouseUp = () => {\n    this.setState({ mouseIsClicked: false });\n  };\n\n  onMouseEnter = (row, column) => {\n    const { startNodeExits, endNodeExists, graph, mouseIsClicked } = this.state;\n    const { start, end, wall } = graph[row][column];\n\n    if (!mouseIsClicked) return;\n    if (endNodeExists && startNodeExits && !end && !start && !wall) {\n      let newGraph = setWall(graph, row, column);\n      this.setState({ graph: newGraph });\n    }\n  };\n\n  // clears the board of wall and search nodes\n  resetField() {\n    const { graph } = this.state;\n    graph.forEach((row, rowIndex) => {\n      return row.forEach((node, nodeIndex) => {\n        if (\n          document.getElementById([rowIndex, nodeIndex]).className ===\n            \"node-shortest-path\" ||\n          document.getElementById([rowIndex, nodeIndex]).className ===\n            \"node-search\" ||\n          document.getElementById([rowIndex, nodeIndex]).className ===\n            \"node-wall\"\n        ) {\n          deleteWall(graph, rowIndex, nodeIndex);\n          document.getElementById([rowIndex, nodeIndex]).className = \"node\";\n        }\n      });\n    });\n  }\n\n  // clears the board of the search\n  clearSearch() {\n    const { graph } = this.state;\n    graph.forEach((row, rowIndex) => {\n      return row.forEach((node, nodeIndex) => {\n        if (\n          document.getElementById([rowIndex, nodeIndex]).className ===\n            \"node-shortest-path\" ||\n          document.getElementById([rowIndex, nodeIndex]).className ===\n            \"node-search\"\n        )\n          return (document.getElementById([rowIndex, nodeIndex]).className =\n            \"node\");\n      });\n    });\n  }\n\n  visualizeDijkstras() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const dijkstras = new Dijkstras(graph, startNode, endNode);\n      const { shortestPath, visitedNodes } = dijkstras.shortestPath();\n      animateSearchProcess(visitedNodes, shortestPath);\n    }\n  }\n\n  visualizeAStar() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const A_Star = new AStar(graph, startNode, endNode);\n      const { shortestPath, visitedNodes } = A_Star.shortestPath();\n      animateSearchProcess(visitedNodes, shortestPath);\n    }\n    return;\n  }\n\n  visualizeDFS() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const DFS = new DepthFirstSearch(graph, startNode, endNode);\n      const { path, visitedNodes } = DFS.search();\n      animateSearchProcess(visitedNodes, path);\n    }\n  }\n\n  visualizeBFS() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const BFS = new BreadthFirstSearch(graph, startNode, endNode);\n      const { path, visitedNodes } = BFS.search();\n      animateSearchProcess(visitedNodes, path);\n    }\n  }\n\n  visualizeGreedyBFS() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const GBFS = new GreedyBFS(graph, startNode, endNode);\n      const { shortestPath, visitedNodes } = GBFS.shortestPath();\n      animateSearchProcess(visitedNodes, shortestPath);\n    }\n  }\n\n  visualizeMaze() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const maze = new RecursiveBacktracking(graph, startNode, endNode);\n      createWalledGraph(graph, startNode, endNode);\n      setTimeout(() => animateMaze(maze.runMaze(), graph, endNode), 2000);\n    }\n  }\n  visualizeTree() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const maze = new BinaryTreeMaze(graph, startNode, endNode);\n      createWalledGraph(graph, startNode, endNode);\n      setTimeout(() => animateMaze(maze.runMaze(), graph, endNode), 2000);\n    }\n  }\n\n  visualizeDivMaze() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      // reset field so we get a clear field\n      this.resetField();\n      const maze = new RecursiveDivision(graph, startNode, endNode);\n      animateDivMaze(maze.runMaze(), graph);\n    }\n  }\n\n  render() {\n    const { graph } = this.state;\n    // create the board.\n    let board = graph.map((row, rowIndex) => {\n      return (\n        // each row must be in a div so you can form a field in css\n        <div className=\"Row\" key={rowIndex}>\n          {row.map((node, nodeIndex) => {\n            // destructuring node object\n            const { row, column, wall, start, end } = node;\n            return (\n              <Node\n                key={nodeIndex}\n                row={row}\n                column={column}\n                wall={wall}\n                start={start}\n                end={end}\n                onMouseEnter={() => this.onMouseEnter(rowIndex, nodeIndex)}\n                onMouseDown={() => this.onMouseDown(rowIndex, nodeIndex)}\n                onMouseUp={() => this.onMouseUp(rowIndex, nodeIndex)}\n                onClick={() => this.onClick(rowIndex, nodeIndex)}\n              />\n            );\n          })}\n        </div>\n      );\n    });\n\n    return (\n      <div className=\"Visualizer\">\n        <ControlPanel\n          visualizeAStar={() => this.visualizeAStar()}\n          visualizeMaze={() => this.visualizeMaze()}\n          visualizeDijkstras={() => this.visualizeDijkstras()}\n          visualizeDivMaze={() => this.visualizeDivMaze()}\n          visualizeGreedyBFS={() => this.visualizeGreedyBFS()}\n          visualizeTree={() => this.visualizeTree()}\n          visualizeDFS={() => this.visualizeDFS()}\n          visualizeBFS={() => this.visualizeBFS()}\n          resetField={() => this.resetField()}\n          clearSearch={() => this.clearSearch()}\n        />\n        <div className=\"Field\">{board}</div>\n      </div>\n    );\n  }\n}\n\nexport default Field;\n","import React, { Component } from \"react\";\n// CSS\nimport \"./Navbar.css\";\n\nclass Navbar extends Component {\n  render() {\n    return (\n      <div className=\"navbar\">\n        <nav>\n          <label id=\"title\">Algorithm Visualizer</label>\n          <a className=\"git-link\" href=\"https://github.com/Atska/visualizer\">\n            Github\n          </a>\n        </nav>\n      </div>\n    );\n  }\n}\n\nexport default Navbar;\n","import React from \"react\";\n//Components\nimport Visualizer from \"./components/Visualizer.js\";\nimport Navbar from \"./components/Navbar.js\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Navbar />\n      <Visualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}