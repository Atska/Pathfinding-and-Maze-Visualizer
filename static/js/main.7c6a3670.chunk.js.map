{"version":3,"sources":["components/Node.js","components/ControlPanel.js","utils/PriorityQueue.js","utils/helperFunctions.js","algorithms/SearchAlgorithms/A_Star.js","algorithms/SearchAlgorithms/DijkstrasAlgorithm.js","algorithms/SearchAlgorithms/GreedyBestFirstSearch.js","algorithms/SearchAlgorithms/DepthFirstSearch.js","utils/Set.js","algorithms/SearchAlgorithms/BreadthFirstSearch.js","algorithms/MazeAlgorithms/BinaryTreeMaze.js","algorithms/MazeAlgorithms/RecursiveDivision.js","algorithms/MazeAlgorithms/RecursiveBacktracking.js","components/Visualizer.js","components/Navbar.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","this","row","column","start","end","wall","onMouseDown","onMouseUp","onClick","onMouseEnter","id","className","Component","ControlPanel","visualizeAStar","visualizeMaze","visualizeDijkstras","visualizeDivMaze","visualizeGreedyBFS","visualizeTree","visualizeDFS","visualizeBFS","resetField","clearSearch","PriorityQueue","values","val","priority","newNode","push","bubbleUp","idx","length","element","parentIdx","Math","floor","parent","min","pop","sinkDown","leftChildIdx","rightChildIdx","leftChild","rightChild","swap","getNeighbors","curr_node","graph","neighbors","rowSize","columnSize","setUpCostMap","startNode","cost","map","rowIndex","node","nodeIndex","location","G","Infinity","filterStartAndEndNode","wallList","newArr","index","equalityChecker","arr1","arr2","shuffleArray","a","i","j","random","AStar","endNode","result","visitedNodes","prevNode","queue","enqueue","costMap","H","F","dequeue","reverse","neighborList","ManhattenDistance","shortestPath","abs","Dijkstras","distanceMap","setUpDistances","shift","sum_distance","distances","GreedyBestFirstSearch","DepthFirstSearch","stack","previousNodes","visited","setUpVisitedMap","allNeighbors","neighborNode","path","Set","value","isEmpty","checkIfDublicate","array","BreadthFirstSearch","currentNode","elem","add","get","BinaryTreeMaze","forEach","chosenNeighbor","flipCoin","inBetweenNode","getInBetweenNode","neighborArray","RecursiveDivision","endX","endY","mazeDivision","isHorizontal","startX","startY","wallX","randomNum","gap","divideVertically","wallY","divideHorizontally","max","width","height","wallLength","RecursiveBacktracking","mazeList","dfs","unvisitedNeigh","getUnvisitedNeighbors","neighbor","getInBetweenNodes","neigh","col","unvisited","filter","undefined","Field","rowsize","startNodeExits","endNodeExists","mouseIsClicked","setStartNode","setState","deleteStartNode","setEndNode","deleteEndNode","newGraph","setWall","deleteWall","createGraph","document","getElementById","animateSearchProcess","search","GreedyBFS","maze","createWalledGraph","setTimeout","animateMaze","runMaze","animateDivMaze","board","key","colSize","isWall","isStart","isEnd","basecase","currentRow","createNode","nodeSchema","currRow","currColumn","animateShortestPath","Navbar","href","App","Boolean","window","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.7c6a3670.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\n/**\n * Creates a node as a square.\n */\nclass Node extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n  render() {\n    const {\n      row,\n      column,\n      start,\n      end,\n      wall,\n      onMouseDown,\n      onMouseUp,\n      onClick,\n      onMouseEnter,\n    } = this.props;\n    // Sets the css className of Node and check whether its start, end or normal colored\n    const className = () => {\n      if (start) return \"node-start\";\n      if (end) return \"node-end\";\n      if (wall && !end && !start) return \"node-wall\";\n      return \"node\";\n    };\n    return (\n      <div\n        id={[row, column]}\n        className={className()}\n        onMouseEnter={() => onMouseEnter()}\n        onMouseUp={() => onMouseUp()}\n        onMouseDown={() => onMouseDown()}\n        onClick={() => onClick()}\n      ></div>\n    );\n  }\n}\n\nexport default Node;\n","import React, { Component } from \"react\";\n// CSS\nimport \"./ControlPanel.css\";\n\nclass ControlPanel extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n  render() {\n    const {\n      visualizeAStar,\n      visualizeMaze,\n      visualizeDijkstras,\n      visualizeDivMaze,\n      visualizeGreedyBFS,\n      visualizeTree,\n      visualizeDFS,\n      visualizeBFS,\n      resetField,\n      clearSearch,\n    } = this.props;\n\n    return (\n      <div className=\"ControlPanel\">\n        <div className=\"Search\">\n          <p>Search Algorithms</p>\n          <br />\n          <button onClick={() => visualizeAStar()}>AStar</button>\n          <br />\n          <button onClick={() => visualizeDijkstras()}>Dijkstra's</button>\n          <br />\n          <button onClick={() => visualizeGreedyBFS()}>\n            GreedyBestFirstSearch\n          </button>\n          <br />\n          <button onClick={() => visualizeDFS()}>DepthFirstSearch</button>\n          <br />\n          <button onClick={() => visualizeBFS()}>BreadthFirstSearch</button>\n        </div>\n        <div className=\"Maze\">\n          <p>Maze Algorithms</p>\n          <button onClick={() => visualizeTree()}>BinaryTreeMaze</button>\n          <button onClick={() => visualizeMaze()}>RecursiveBacktracking</button>\n          <button onClick={() => visualizeDivMaze()}>RecursiveDivision</button>\n        </div>\n        <div className=\"Reset\">\n          <button onClick={() => resetField()}>Reset Field</button>\n          <br />\n          <button onClick={() => clearSearch()}>Clear Search</button>\n        </div>\n      </div>\n    );\n  }\n}\nexport default ControlPanel;\n","/**\n * A priority queue or min heap is a datastructure in an array which shuffles newly added\n * values based on their priority. Smaller numbers mean higher priority\n */\nclass PriorityQueue {\n  constructor() {\n    this.values = [];\n  }\n  /**\n   * @returns {Array}\n   */\n  get() {\n    return this.values;\n  }\n  /**\n   * Adds value to array.\n   * @param {Object} val Any object you want to store.\n   * @param {Number} priority Integer. Lower number means higher priority.\n   */\n  enqueue(val, priority) {\n    let newNode = new Node(val, priority);\n    this.values.push(newNode);\n    this.bubbleUp();\n  }\n  /**\n   * Restructures array.\n   */\n  bubbleUp() {\n    let idx = this.values.length - 1;\n    const element = this.values[idx];\n    while (idx > 0) {\n      let parentIdx = Math.floor((idx - 1) / 2);\n      let parent = this.values[parentIdx];\n      if (element.priority >= parent.priority) break;\n      this.values[parentIdx] = element;\n      this.values[idx] = parent;\n      idx = parentIdx;\n    }\n  }\n  /**\n   *\n   */\n  dequeue() {\n    const min = this.values[0];\n    const end = this.values.pop();\n    if (this.values.length > 0) {\n      this.values[0] = end;\n      this.sinkDown();\n    }\n    return min;\n  }\n  /**\n   *\n   */\n  sinkDown() {\n    let idx = 0;\n    const length = this.values.length;\n    const element = this.values[0];\n    while (true) {\n      let leftChildIdx = 2 * idx + 1;\n      let rightChildIdx = 2 * idx + 2;\n      let leftChild, rightChild;\n      let swap = null;\n\n      if (leftChildIdx < length) {\n        leftChild = this.values[leftChildIdx];\n        if (leftChild.priority < element.priority) {\n          swap = leftChildIdx;\n        }\n      }\n      if (rightChildIdx < length) {\n        rightChild = this.values[rightChildIdx];\n        if (\n          (swap === null && rightChild.priority < element.priority) ||\n          (swap !== null && rightChild.priority < leftChild.priority)\n        ) {\n          swap = rightChildIdx;\n        }\n      }\n      if (swap === null) break;\n      this.values[idx] = this.values[swap];\n      this.values[swap] = element;\n      idx = swap;\n    }\n  }\n}\n\nclass Node {\n  constructor(val, priority) {\n    this.val = val;\n    this.priority = priority;\n  }\n}\n\nexport { PriorityQueue, Node };\n","/**\n * Gets the values of the coordinates of neighboring nodes. Only top, right, bottom and left neighbors.\n * @param {Object} curr_node Current node object\n * @param {Array} graph 2D graph consisting of node objects\n * @returns Array of all the valid coordinates [row, column] of neighboring nodes in an array\n */\nexport const getNeighbors = (curr_node, graph) => {\n  // find neighboring nodes; current[0] = row; currentrow[1] = column\n  const neighbors = [];\n  const rowSize = graph.length - 1;\n  const columnSize = graph[0].length - 1;\n  //right neighbor\n  if (curr_node[1] < columnSize)\n    neighbors.push([curr_node[0], curr_node[1] + 1]);\n  //bottom neighbor\n  if (curr_node[0] < rowSize) neighbors.push([curr_node[0] + 1, curr_node[1]]);\n  //left neighbor\n  if (curr_node[1] > 0) neighbors.push([curr_node[0], curr_node[1] - 1]);\n  //top neighbor\n  if (curr_node[0] > 0) neighbors.push([curr_node[0] - 1, curr_node[1]]);\n  return neighbors;\n};\n\n/**\n * Hashmap for keeping track of the cost of a node to determine the shortest path.\n * The cost of a node is the distance of the node to the start\n * Start cost is 0 and every unvisited node positive Infinity\n * @param {Array} graph 2D graph consisting of node objects\n * @param {Array} queue Queue as an Array\n * @returns {Object} Whole grid in an javascript object. Keys are arrays [row, column] and values are objects\n */\nexport const setUpCostMap = (graph, startNode) => {\n  let cost = {};\n  graph.map((row, rowIndex) => {\n    // eslint-disable-next-line array-callback-return\n    return row.map((node, nodeIndex) => {\n      let location = [node.row, node.column];\n      if (node === startNode) {\n        cost[location] = { G: 0 };\n      } else {\n        cost[location] = { G: Infinity };\n      }\n    });\n  });\n  return cost;\n};\n\n/**\n * Simple function to filter the start and end nodes out of the wall\n * This is only for frontend purposes, so you dont overwrite start and end nodes will walls\n * @param {Array} wallList array of all wall nodes\n * @param {Array} start [row, column] coordinates of the start node\n * @param {Array} end [row, column] coordinates of the end node\n * @returns {Array} filtered array\n */\nexport const filterStartAndEndNode = (wallList, start, end) => {\n  if (!wallList || !start || !end) return false;\n  let newArr = [];\n  for (let index = 0; index < wallList.length; index++) {\n    const element = wallList[index];\n    if (!equalityChecker(start, element) && !equalityChecker(end, element)) {\n      newArr.push(element);\n    }\n  }\n  wallList = newArr;\n  return wallList;\n};\n\n/**\n * Compares two array with two values [val1, val2] and checks if their values are the same\n * @param {Array} arr1 Array with two values -> [3, 3]\n * @param {Array} arr2 Array with two values -> [3, 3]\n * @returns Boolean; If array values are same -> true else -> false\n */\nexport const equalityChecker = (arr1, arr2) => {\n  if (arr1[0] === arr2[0] && arr1[1] === arr2[1]) return true;\n  return false;\n};\n\n/**\n * Shuffles an array and returns shuffled array\n * @param {Array} a Any array\n * @returns shuffled array\n */\nexport const shuffleArray = (a) => {\n  for (let i = a.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [a[i], a[j]] = [a[j], a[i]];\n  }\n  return a;\n};\n\nexport const createNode = (row, column) => {\n  const nodeSchema = {\n    row: row,\n    column: column,\n    wall: false,\n    start: false,\n    end: false,\n  };\n  return nodeSchema;\n};\n\nexport const createGraph = () => {\n  const graph = [];\n  let rowSize = 21;\n  let colSize = 35;\n  // create a 2D Array\n  for (let row = 0; row < rowSize; row++) {\n    const currentRow = [];\n    for (let column = 0; column < colSize; column++) {\n      // create an object with node coordinates. Starts and end return a true bool when they hit the coordinates\n      currentRow.push(createNode(row, column));\n    }\n    graph.push(currentRow);\n  }\n  return graph;\n};\n","import { PriorityQueue } from \"../../utils/PriorityQueue.js\";\nimport {\n  getNeighbors,\n  setUpCostMap,\n  equalityChecker,\n} from \"../../utils/helperFunctions.js\";\n\n/**\n * The A-Star algorithm is an extension of dijkstras and return the shortest path between 2 nodes\n * It uses a score to determine the direction to travel\n * The formula is F = G + H.\n * G is the distance from the node to the start node.\n * H is based on the Manhatten distance\n * F is the sum of G and H.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass AStar {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n    this.result = [];\n    this.visitedNodes = [];\n  }\n\n  shortestPath() {\n    if (!this.graph || !this.startNode || !this.endNode) return false;\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n    let prevNode = { start: null };\n    let queue = new PriorityQueue();\n    queue.enqueue(start, 0);\n    // setUp distances grid in a hashmap -> distanceMap[[0, 0]]\n    const costMap = setUpCostMap(this.graph, this.startNode);\n    costMap[start] = { G: 0, H: 0, F: 0 };\n    // while nodes to visit still exists\n    while (queue.values.length) {\n      //Get the enqueued array\n      let curr_node = queue.dequeue().val;\n      // if wall skip it and continue\n      if (this.graph[curr_node[0]][curr_node[1]].wall === true) continue;\n      // EndCondition: Check if current node is the end node -> finish\n      if (equalityChecker(curr_node, end)) {\n        // traverse the prevNode object to get all coordinates in an Array\n        while (prevNode[curr_node]) {\n          this.result.push(curr_node);\n          curr_node = prevNode[curr_node];\n        }\n        // Order the array from start to end node\n        this.result.reverse();\n        break;\n      }\n\n      if (curr_node) {\n        // gets an array of neighbors\n        let neighborList = getNeighbors(curr_node, this.graph);\n        for (let i = 0; i < neighborList.length; i++) {\n          // G: Similar to dijkstras its the distance between the current node and the start\n          const G = costMap[curr_node][\"G\"] + 1;\n          // H: The Heuristik. Manhatten distance\n          const H = this.ManhattenDistance(neighborList[i], end);\n          // F: New Score to determine shortest path\n          const F = G + H;\n          // important for shortest path. Avoids checking nodes twice and updates shortest path\n          if (G < costMap[neighborList[i]][\"G\"]) {\n            // Avoids overlapping visited nodes with walled nodes and filters end node for front end purposes\n            if (\n              !this.graph[neighborList[i][0]][neighborList[i][1]].wall &&\n              !equalityChecker(neighborList[i], end)\n            )\n              this.visitedNodes.push(neighborList[i]);\n            costMap[neighborList[i]] = { G: G };\n            prevNode[neighborList[i]] = curr_node;\n            queue.enqueue(neighborList[i], F);\n          }\n        }\n      }\n    }\n    return { shortestPath: this.result, visitedNodes: this.visitedNodes };\n  }\n\n  ManhattenDistance(node, end) {\n    return Math.abs(end[0] - node[0]) + Math.abs(end[1] - node[1]);\n  }\n}\n\nexport default AStar;\n","import { getNeighbors, equalityChecker } from \"../../utils/helperFunctions.js\";\n\n/**\n * Classic dijkstras is an algorithm for finding the shortest path between 2 nodes.\n * Usually you need a PriorityQueue/Heap data structure but the distant between nodes\n * is constant 1 so you can use a queue\n *\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass Dijkstras {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  shortestPath() {\n    if (!this.graph || !this.startNode || !this.endNode) return false;\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n    let prevNode = {};\n    let queue = [start];\n    const result = [];\n    const visitedNodes = [];\n    // setUp distances grid in a hashmap -> distanceMap[[0, 0]]\n    const distanceMap = this.setUpDistances(this.graph, this.startNode);\n\n    // while nodes to visit still exists\n    while (queue.length) {\n      let curr_node = queue.shift();\n      // if wall skip it and continue\n      if (this.graph[curr_node[0]][curr_node[1]].wall === true) continue;\n      // EndCondition: Check if current node is the end node -> finish\n      if (equalityChecker(curr_node, end)) {\n        // traverse the prevNode object to get all coordinates in an Array\n        while (prevNode[curr_node]) {\n          result.push(curr_node);\n          curr_node = prevNode[curr_node];\n        }\n        // Order the array from start to end node\n        result.reverse();\n        break;\n      }\n\n      if (curr_node) {\n        // removes first node for visual effect in frontend\n        if (curr_node !== start) visitedNodes.push(curr_node);\n        // gets an array of neighbors\n        let neighborList = getNeighbors(curr_node, this.graph);\n        for (let i = 0; i < neighborList.length; i++) {\n          // Determine the cost \"G\" of a node\n          // adds the distance of the current node with its neighbors which is always 1\n          let sum_distance = distanceMap[curr_node] + 1;\n          if (sum_distance < distanceMap[neighborList[i]]) {\n            prevNode[neighborList[i]] = curr_node;\n            distanceMap[neighborList[i]] = sum_distance;\n            queue.push(neighborList[i]);\n          }\n        }\n      }\n    }\n    return { shortestPath: result, visitedNodes: visitedNodes };\n  }\n\n  /**\n   * Based on graph, put every node into an javascript object as a key and set their value\n   * to Infinity and the start to 0\n   * @param {Array} graph 2D graph consisting of node objects\n   * @param {Array} queue Queue as an Array\n   */\n  setUpDistances(graph, startNode) {\n    let distances = {};\n    graph.map((row, rowIndex) => {\n      // eslint-disable-next-line array-callback-return\n      return row.map((node, nodeIndex) => {\n        let location = [node.row, node.column];\n        if (node === startNode) {\n          distances[location] = 0;\n        } else {\n          distances[location] = Infinity;\n        }\n      });\n    });\n    return distances;\n  }\n}\n\nexport default Dijkstras;\n","import { PriorityQueue } from \"../../utils/PriorityQueue.js\";\nimport {\n  getNeighbors,\n  setUpCostMap,\n  equalityChecker,\n} from \"../../utils/helperFunctions.js\";\n\n/**\n * The Greedy Best-First-Search determines the shortest path between 2 nodes\n * It uses a score to determine the direction to travel\n * The formula is F = G + H.\n * G is the distance from the node to the start node.\n * H is based on the Pythagorean theorem.\n * F is the sum of G and H.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass GreedyBestFirstSearch {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  shortestPath() {\n    if (!this.graph || !this.startNode || !this.endNode) return false;\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n    let prevNode = { start: null };\n    const result = [];\n    const visitedNodes = [];\n    let queue = new PriorityQueue();\n    queue.enqueue(start, 0);\n    // setUp distances grid in a hashmap -> distanceMap[[0, 0]]\n    const costMap = setUpCostMap(this.graph, this.startNode);\n    costMap[start] = { G: 0, H: 0, F: 0 };\n    // while nodes to visit still exists\n    while (queue.values.length) {\n      //Get the enqueued array\n      let curr_node = queue.dequeue().val;\n      // if wall skip it and continue\n      if (this.graph[curr_node[0]][curr_node[1]].wall === true) continue;\n      // EndCondition: Check if current node is the end node -> finish\n      if (equalityChecker(curr_node, end)) {\n        // traverse the prevNode object to get all coordinates in an Array\n        while (prevNode[curr_node]) {\n          result.push(curr_node);\n          curr_node = prevNode[curr_node];\n        }\n        // Order the array from start to end node\n        result.reverse();\n        break;\n      }\n\n      if (curr_node) {\n        // gets an array of neighbors\n        let neighborList = getNeighbors(curr_node, this.graph);\n        for (let i = 0; i < neighborList.length; i++) {\n          // G: Similar to dijkstras its the distance between the current node and the start\n          const G = costMap[curr_node][\"G\"] + 1;\n          // H: The Heuristik. Pythagorean theorem\n          const H =\n            (neighborList[i][0] - end[0]) ** 2 +\n            (neighborList[i][1] - end[1]) ** 2;\n\n          // F: New Score to determine shortest path\n          const F = G + H;\n          // important for shortest path. Avoids checking nodes twice and updates shortest path\n          if (G < costMap[neighborList[i]][\"G\"]) {\n            // Avoids overlapping visited nodes with walled nodes and filters end node for front end purposes\n            if (\n              !this.graph[neighborList[i][0]][neighborList[i][1]].wall &&\n              !equalityChecker(neighborList[i], end)\n            )\n              visitedNodes.push(neighborList[i]);\n            costMap[neighborList[i]] = { G: G };\n            prevNode[neighborList[i]] = curr_node;\n            queue.enqueue(neighborList[i], F);\n          }\n        }\n      }\n    }\n    return { shortestPath: result, visitedNodes: visitedNodes };\n  }\n}\n\nexport default GreedyBestFirstSearch;\n","import { equalityChecker, getNeighbors } from \"../../utils/helperFunctions.js\";\n/**\n * The depth-first-search is a classic algorithm for traveling trees or graphs.\n * Its not a good algorithm for pathfinding and rarely delivers the shortest path.\n * The algorithm itself is done iteratly with a stack data structure.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass DepthFirstSearch {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  search() {\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n    const result = [];\n    const visitedNodes = [];\n    const stack = [start];\n    const previousNodes = {};\n    const visited = this.setUpVisitedMap(this.graph, this.startNode);\n\n    while (stack.length > 0) {\n      let curr_node = stack.pop();\n      visited[curr_node] = true;\n      //Found the node\n      if (equalityChecker(curr_node, end)) {\n        // traverse the prevNode object to get all coordinates in an Array\n        while (previousNodes[curr_node]) {\n          result.push(curr_node);\n          curr_node = previousNodes[curr_node];\n        }\n        // Order the array from start to end node\n        result.reverse();\n        break;\n      }\n      // if its a wall => skip\n      if (this.graph[curr_node[0]][curr_node[1]].wall === true) continue;\n      // get all neighbors of the current node\n      const allNeighbors = getNeighbors(curr_node, this.graph);\n      for (let i = 0; i < allNeighbors.length; i++) {\n        const neighborNode = allNeighbors[i];\n        // check if node wasnt visited otherwise ignore it\n        if (!visited[neighborNode]) {\n          // put the unvisited node on the stack for backtracking\n          stack.push(neighborNode);\n          previousNodes[neighborNode] = curr_node;\n          // for frontend purposes: Check if neighbors arent walls or endNode\n          if (\n            !this.graph[neighborNode[0]][neighborNode[1]].wall &&\n            !equalityChecker(neighborNode, end)\n          )\n            visitedNodes.push(neighborNode);\n        }\n      }\n    }\n    return { path: result, visitedNodes: visitedNodes };\n  }\n\n  setUpVisitedMap(graph, startNode) {\n    const visited = {};\n    graph.map((row, rowIndex) => {\n      // eslint-disable-next-line array-callback-return\n      return row.map((node, nodeIndex) => {\n        let location = [node.row, node.column];\n        visited[location] = false;\n      });\n    });\n    return visited;\n  }\n}\n\nexport default DepthFirstSearch;\n","class Set {\n  constructor() {\n    this.values = [];\n  }\n\n  get() {\n    return this.values;\n  }\n\n  isEmpty() {\n    if (this.values.length === 0) return true;\n    return false;\n  }\n\n  add(value) {\n    if (this.isEmpty()) return this.values.push(value);\n    if (!checkIfDublicate(value, this.values)) return this.values.push(value);\n  }\n\n  has(value) {\n    return checkIfDublicate(value, this.values);\n  }\n}\n\nexport default Set;\n\n/**\n * Compares two array with two values [val1, val2] and checks if their values are the same\n * @param {Array} arr1 Array with two values -> [3, 3]\n * @param {Array} arr2 Array with two values -> [3, 3]\n * @returns Boolean; If array values are same -> true else -> false\n */\nconst equalityChecker = (arr1, arr2) => {\n  if (arr1[0] === arr2[0] && arr1[1] === arr2[1]) return true;\n  return false;\n};\n\n/**\n * Checks if there is a dublicate value in an array\n * @param {Array} value single array [val1, val2]\n * @param {Array} array values in the set\n */\nconst checkIfDublicate = (value, array) => {\n  for (let i = 0; i < array.length; i++) {\n    const element = array[i];\n    if (equalityChecker(element, value)) return true;\n  }\n  return false;\n};\n","import { equalityChecker, getNeighbors } from \"../../utils/helperFunctions.js\";\nimport Set from \"../../utils/Set.js\";\n/**\n * The breadth-first-search is a classic tree or graph traversal algorithm.\n * It is an uninformed algorithm which guarantees the shortest path.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass BreadthFirstSearch {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n    this.result = [];\n    this.visitedNodes = new Set();\n  }\n\n  search() {\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n\n    const queue = [start];\n    const previousNodes = {};\n    const visited = this.setUpVisitedMap(this.graph, this.startNode);\n\n    while (queue.length > 0) {\n      let currentNode = queue.shift();\n      // set the startnode to visited\n      if (equalityChecker(currentNode, start)) visited[currentNode] = true;\n      // if wall current node is a wall => skip node\n      if (this.graph[currentNode[0]][currentNode[1]].wall === true) continue;\n      // end condition\n      if (equalityChecker(currentNode, end)) {\n        // traverse the prevNode object to get all coordinates in an Array\n        while (previousNodes[currentNode]) {\n          this.result.push(currentNode);\n          currentNode = previousNodes[currentNode];\n        }\n        // Order the array from start to end node\n        this.result.reverse();\n        break;\n      }\n      // get neighbors of the current node\n      const neighbors = getNeighbors(currentNode, this.graph);\n      for (let i = 0; i < neighbors.length; i++) {\n        const elem = neighbors[i];\n        if (!visited[elem]) {\n          visited[elem] = true;\n          queue.push(elem);\n          previousNodes[elem] = currentNode;\n          if (!equalityChecker(currentNode, start))\n            this.visitedNodes.add(currentNode);\n        }\n      }\n    }\n    return { path: this.result, visitedNodes: this.visitedNodes.get() };\n  }\n\n  setUpVisitedMap(graph, startNode) {\n    const visited = {};\n    graph.map((row, rowIndex) => {\n      // eslint-disable-next-line array-callback-return\n      return row.map((node, nodeIndex) => {\n        let location = [node.row, node.column];\n        visited[location] = false;\n      });\n    });\n    return visited;\n  }\n}\n\nexport default BreadthFirstSearch;\n","import {\n  shuffleArray,\n  filterStartAndEndNode,\n} from \"../../utils/helperFunctions.js\";\nimport Set from \"../../utils/Set.js\";\n\n/**\n * This algorithm is based on the binary tree data structure.\n * Like the binary tree every branch has to children.\n * There will never be a crossroads, and all dead ends have passages pointing down or right,\n * and never up or left.\n * Two of the four sides will form a corridor where no wall can exists.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass BinaryTreeMaze {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  runMaze() {\n    // we need a Set data structure to prevnt dublicate entries\n    const result = new Set();\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n\n    // iterate through the graph\n    this.graph.forEach((row, rowIndex) => {\n      row.forEach((node, nodeIndex) => {\n        // because of the grid design of the app, always skip a row to form the wall nodes\n        // horitontal / vertical walls are always on even rows and columns\n        if (rowIndex % 2 === 0 && nodeIndex % 2 === 0) {\n          const allNeighbors = this.getNeighbors(rowIndex, nodeIndex);\n          if (allNeighbors) {\n            const { currentNode, neighbors } = allNeighbors;\n            const chosenNeighbor = this.flipCoin(neighbors);\n            const inBetweenNode = this.getInBetweenNode(\n              currentNode,\n              chosenNeighbor\n            );\n            result.add(chosenNeighbor);\n            result.add(inBetweenNode);\n            result.add(currentNode);\n          }\n        }\n      });\n    });\n    return filterStartAndEndNode(result.get(), start, end);\n  }\n\n  /**\n   * Get north or west neighbors of the current node.\n   * Must travel 2 nodes [2, 2] => west neighbor [2,0] because of the grid design\n   * @param {Int} row row number of the current node\n   * @param {Int} column column number of the current node\n   * @returns {Object} {currentNode: [currentNode-row, currentNode-column], neighbots: [All neighbors as arrays]}\n   */\n  getNeighbors(row, column) {\n    let neighbors = [];\n    // north\n    if (row >= 2) neighbors.push([row - 2, column]);\n    // west\n    if (column >= 2) neighbors.push([row, column - 2]);\n    // skip node which has no north or west neighbors\n    if (neighbors.length === 0) return;\n    return { currentNode: [row, column], neighbors: neighbors };\n  }\n  /**\n   * Shuffles an array and returns first value of shuffled array to get a random neighbor\n   * @param {Array} neighborArray Array of all neighbors\n   * @returns {Array} returns one array of the row and column data of the neighbor node\n   */\n  flipCoin(neighborArray) {\n    if (neighborArray.length === 1) return neighborArray[0];\n    return shuffleArray(neighborArray)[0];\n  }\n  /**\n   * We travel 2 nodes at the same time. If we set the current node and the neighbor node to\n   * passable nodes we need to make the in between node of both to a passable node too.\n   * @param {Array} currentNode coordinates of the current node\n   * @param {Array} neighborNode coordinates of the neighbor node\n   * @returns {Array}\n   */\n  getInBetweenNode(currentNode, neighborNode) {\n    const row = currentNode[0] - neighborNode[0];\n    const column = currentNode[1] - neighborNode[1];\n    // get north in between node\n    if (row !== 0) return [currentNode[0] - 1, currentNode[1]];\n    // get west in between node\n    if (column !== 0) return [currentNode[0], currentNode[1] - 1];\n  }\n}\n\nexport default BinaryTreeMaze;\n","import { filterStartAndEndNode } from \"../../utils/helperFunctions.js\";\n/**\n * The recursive divison is an algorithm which splits a grid either horizontal or vertical.\n * You have to determine a random coordinate and draw the wall.\n * The wall has to have a randomly generated gap.\n * By dividing the grid you create subgrids which have to be divided and walled again\n * Therefore you need to call 4 recursions: If split vertically left and right, otherwise if split horizontal top and bottom.\n * The recursive function stops when the difference between end and start coordinates is 1.\n *\n * It is important to notice that the walls must have 1 passable node in between each other.\n * At the coordinate of the gap cannot be a wall.\n * The most sensitive part of this algorithm is in generating random values for gap and walls.\n *\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\n\nexport class RecursiveDivision {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n  // executes the maze\n  runMaze() {\n    let wallList = [];\n    const startX = 0;\n    const startY = 0;\n    const endX = this.graph[0].length - 1;\n    const endY = this.graph.length - 1;\n    const start = [this.startNode.row, this.startNode.column];\n    const end = [this.endNode.row, this.endNode.column];\n    // fill wallList with Arrays of coordinates -> [row, column]\n    this.mazeDivision(\n      startX,\n      startY,\n      endX,\n      endY,\n      this.isHorizontal(),\n      wallList\n    );\n    // filter the newly filled wallList. This is optional for the frontend, so you dont wall a start or end node\n    wallList = filterStartAndEndNode(wallList, start, end);\n    return wallList;\n  }\n\n  mazeDivision(startX, startY, endX, endY, isHorizontal, wallList) {\n    if (!isHorizontal) {\n      if (endX - startX < 2) {\n        return;\n      }\n      // generate the random x coordinate for the wall\n      let wallX = Math.floor(this.randomNum(startX + 1, endX) / 2) * 2;\n      // generate the random x coordinate for the gap\n      let gap =\n        Math.floor(Math.floor(Math.random() * (endY - startY) + startY) / 2) *\n          2 +\n        1;\n      // set up vertical walls based on wall x and gap\n      this.divideVertically(startY, wallX, endY, gap, wallList);\n\n      this.mazeDivision(\n        startX,\n        startY,\n        wallX - 1,\n        endY,\n        this.isHorizontal(wallX - 1 - startX, endY - startY),\n        wallList\n      );\n\n      this.mazeDivision(\n        wallX + 1,\n        startY,\n        endX,\n        endY,\n        this.isHorizontal(endX - (wallX + 1), endY - startY),\n        wallList\n      );\n    }\n\n    if (isHorizontal) {\n      if (endY - startY < 2) {\n        return;\n      }\n      // generate the random x coordinate for the wall\n      let wallY = Math.floor(this.randomNum(startY + 1, endY) / 2) * 2;\n      // generate the random x coordinate for the gap\n      let gap =\n        Math.floor(Math.floor(Math.random() * (endX - startX) + startX) / 2) *\n          2 +\n        1;\n      // set up vertical walls based on wall x and gap\n      this.divideHorizontally(startX, wallY, endX, gap, wallList);\n\n      this.mazeDivision(\n        startX,\n        startY,\n        endX,\n        wallY - 1,\n        this.isHorizontal(endX - startX, wallY - 1 - startY),\n        wallList\n      );\n      this.mazeDivision(\n        startX,\n        wallY + 1,\n        endX,\n        endY,\n        this.isHorizontal(endX - startX, endY - (wallY + 1)),\n        wallList\n      );\n    }\n  }\n  /**\n   * Gets a random int value in range of min and max\n   * @param {int} min smaller value\n   * @param {int} max higher value\n   * @returns random value\n   */\n  randomNum(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  }\n\n  /**\n   * Checks if we have to divide the grid vertically or horizontally\n   * @param {Int} width width of the current grid\n   * @param {Int} height height of the current grid\n   * @returns {Boolean} horizontal or not\n   */\n  isHorizontal(width, height) {\n    if (width < height) {\n      return true;\n    } else if (height < width) {\n      return false;\n    } else {\n      // makes the maze more dynamic\n      return Math.random() < 0.5 ? true : false;\n    }\n  }\n\n  /**\n   * Sets up walls\n   * @param {Int} startY start value of Y coordinate\n   * @param {Int} wallX random generated coordinate of the wall\n   * @param {Int} wallLength height of the grid\n   * @param {Int} gap random generated coordinated of the gap\n   * @param {Array} wallList array of wall coordinates\n   */\n  divideVertically(startY, wallX, wallLength, gap, wallList) {\n    for (let wallY = startY; wallY <= wallLength; wallY++) {\n      if (wallY !== gap) {\n        wallList.push([wallY, wallX]);\n      }\n    }\n  }\n  /**\n   * Sets up walls\n   * @param {Int} startX start value of X coordinate\n   * @param {Int} wallY random generated coordinate of the wall\n   * @param {Int} wallLength height of the grid\n   * @param {Int} gap random generated coordinated of the gap\n   * @param {Array} wallList array of wall coordinates\n   */\n  divideHorizontally(startX, wallY, wallLength, gap, wallList) {\n    for (let wallX = startX; wallX <= wallLength; wallX++) {\n      if (wallX !== gap) {\n        wallList.push([wallY, wallX]);\n      }\n    }\n  }\n}\n\nexport default RecursiveDivision;\n","import { shuffleArray } from \"../../utils/helperFunctions.js\";\n\n/**\n * This algortihm uses a depth-first-search algorithm to traverse the graph.\n * A stack is used to keep track of the visited node and ensures the ability to backtrack if you hit a dead end.\n * The frontend graph looks like a chessboard so you have to traverse 2 nodes at the same time\n * to generate walls and passable nodes.\n * @param {Array} graph 2D-Array/Matrix consisting of specific node objects\n * @param {Object} startNode object with row, column, wall, start, end as keys\n * @param {Object} endNode object with row, column, wall, start, end as keys\n * @returns {Array} Array of wall coordinates in arrays without start and end location\n */\nclass RecursiveBacktracking {\n  constructor(graph, startNode, endNode) {\n    this.graph = graph;\n    this.startNode = startNode;\n    this.endNode = endNode;\n  }\n\n  // executes the recursive backtraking algorithm\n  runMaze() {\n    const start = [this.startNode.row, this.startNode.column];\n    const stack = [start];\n    const visited = {};\n    const mazeList = [];\n    this.dfs(stack, visited, mazeList);\n    // removes first and last for frontend purposes\n    mazeList.shift();\n    mazeList.pop();\n    return mazeList;\n  }\n\n  // depth-first-search algorithm to traverse the graph\n  dfs(stack, visited, mazeList) {\n    // pop current Node in the stack\n    const currentNode = stack.pop();\n    // Will become a wall node\n    mazeList.push(currentNode);\n    // node is visited!\n    visited[currentNode] = true;\n    // TODO: traverse 2 node at the same time -> [0, 0] neighbor are [0, 2] or [2, 0]\n    // get all neighbors which werent visited yet\n    const unvisitedNeigh = this.getUnvisitedNeighbors(currentNode, visited);\n    // hit a dead end -> backtrack!\n    if (unvisitedNeigh.length === 0) {\n      // no value in stack -> dfs is finished\n      if (stack.length === 0) return;\n      // else perform dfs with the node on top of the stack (backtrack)\n      return this.dfs(stack, visited, mazeList);\n    }\n    // has valid neighbors -> put back to stack to backtrack\n    stack.push(currentNode);\n    // get a random unvisited neighbor\n    const neighbor = shuffleArray(unvisitedNeigh).pop();\n    // Remember: We traverse 2 node at the same time -> get in between node\n    const inBetweenNode = this.getInBetweenNodes(currentNode, neighbor);\n    visited[inBetweenNode] = true;\n    mazeList.push(inBetweenNode);\n    // we traversed 2 nodes and set the current location as next node -> recursion with current node\n    stack.push(neighbor);\n    this.dfs(stack, visited, mazeList);\n  }\n\n  /**\n   * We traverse 2 nodes at the same time. Get the in between node\n   * @param {Array} currentNode current location of the node\n   * @param {Array} neigh neighbor node of the current node\n   * @returns {Array} location of the in between node\n   */\n  getInBetweenNodes(currentNode, neigh) {\n    const row = (neigh[0] - currentNode[0]) / 2;\n    const col = (neigh[1] - currentNode[1]) / 2;\n    const inBetweenNode = [currentNode[0] + row, currentNode[1] + col];\n    return inBetweenNode;\n  }\n\n  /**\n   * Gets all unvisited neighbors of current node\n   * @param {Array} currentNode current location of the node\n   * @param {Object} visited Obj which checks if nodes are true (has been visited)\n   * @returns {Array} filtered array of all unvisited nodes\n   */\n  getUnvisitedNeighbors(currentNode, visited) {\n    const rowSize = this.graph.length - 2;\n    const columnSize = this.graph[0].length - 2;\n    const row = currentNode[0];\n    const column = currentNode[1];\n    const unvisited = [];\n    // right\n    if (column < columnSize) {\n      unvisited.push([row, column + 2]);\n    }\n    // bottom\n    if (row < rowSize) {\n      unvisited.push([row + 2, column]);\n    }\n    // left\n    if (column > 1) {\n      unvisited.push([row, column - 2]);\n    }\n    // top\n    if (row > 1) {\n      unvisited.push([row - 2, column]);\n    }\n    return unvisited.filter((i) => {\n      return visited[i] === undefined;\n    });\n  }\n}\n\nexport default RecursiveBacktracking;\n","import React, { Component } from \"react\";\n// Components\nimport Node from \"./Node.js\";\nimport ControlPanel from \"./ControlPanel.js\";\n\n// CSS\nimport \"./Visualizer.css\";\n// Search Algorithms\nimport AStar from \"../algorithms/SearchAlgorithms/A_Star.js\";\nimport Dijkstras from \"../algorithms/SearchAlgorithms/DijkstrasAlgorithm.js\";\nimport GreedyBFS from \"../algorithms/SearchAlgorithms/GreedyBestFirstSearch\";\nimport DepthFirstSearch from \"../algorithms/SearchAlgorithms/DepthFirstSearch.js\";\nimport BreadthFirstSearch from \"../algorithms/SearchAlgorithms/BreadthFirstSearch.js\";\n\n// Maze Algorithms\nimport BinaryTreeMaze from \"../algorithms/MazeAlgorithms/BinaryTreeMaze.js\";\nimport RecursiveDivision from \"../algorithms/MazeAlgorithms/RecursiveDivision.js\";\nimport RecursiveBacktracking from \"../algorithms/MazeAlgorithms/RecursiveBacktracking.js\";\n\nclass Field extends Component {\n  // graph size\n  rowsize = 25;\n  columnSize = 49;\n\n  state = {\n    graph: [],\n    startNodeExits: false,\n    endNodeExists: false,\n    mouseIsClicked: false,\n    startNode: null,\n    endNode: null,\n  };\n\n  // set up field\n  componentDidMount() {\n    const newGraph = createGraph(\n      this.rowsize,\n      this.columnSize,\n      false,\n      false,\n      false\n    );\n    this.setState({ graph: newGraph });\n  }\n\n  onClick = (row, column) => {\n    const { startNodeExits, endNodeExists, graph } = this.state;\n    const { start, end } = graph[row][column];\n\n    // set start node\n    if (!startNodeExits) {\n      setStartNode(graph, row, column);\n      this.setState({ startNodeExits: true, startNode: graph[row][column] });\n    }\n    // delete start node\n    if (startNodeExits && start) {\n      deleteStartNode(graph, row, column);\n      this.setState({ startNodeExits: false, startNode: null });\n    }\n    // set end node\n    if (!endNodeExists && startNodeExits && !start) {\n      setEndNode(graph, row, column);\n      this.setState({ endNodeExists: true, endNode: graph[row][column] });\n    }\n    // delete end node\n    if (endNodeExists && setStartNode && end && !start) {\n      deleteEndNode(graph, row, column);\n      this.setState({ endNodeExists: false, endNode: null });\n    }\n  };\n\n  // on mouse down set up or delete a wall\n  onMouseDown = (row, column) => {\n    const { startNodeExits, endNodeExists, graph, mouseIsClicked } = this.state;\n    const { start, end, wall } = graph[row][column];\n    // if node isnt a wall -> setup the wall\n    if (\n      endNodeExists &&\n      startNodeExits &&\n      !mouseIsClicked &&\n      !end &&\n      !start &&\n      !wall\n    ) {\n      let newGraph = setWall(graph, row, column);\n      this.setState({ graph: newGraph, mouseIsClicked: true });\n    }\n    // if node is a wall -> delete wall\n    if (endNodeExists && startNodeExits && !end && !start && wall) {\n      let newGraph = deleteWall(graph, row, column);\n      this.setState({ graph: newGraph });\n    }\n  };\n\n  onMouseUp = () => {\n    this.setState({ mouseIsClicked: false });\n  };\n\n  //\n  onMouseEnter = (row, column) => {\n    const { startNodeExits, endNodeExists, graph, mouseIsClicked } = this.state;\n    const { start, end, wall } = graph[row][column];\n\n    if (!mouseIsClicked) return;\n    if (endNodeExists && startNodeExits && !end && !start && !wall) {\n      let newGraph = setWall(graph, row, column);\n      this.setState({ graph: newGraph });\n    }\n  };\n\n  // clears the board of wall and search nodes\n  resetField() {\n    const { graph } = this.state;\n    graph.forEach((row, rowIndex) => {\n      return row.forEach((node, nodeIndex) => {\n        if (\n          document.getElementById([rowIndex, nodeIndex]).className ===\n            \"node-shortest-path\" ||\n          document.getElementById([rowIndex, nodeIndex]).className ===\n            \"node-search\" ||\n          document.getElementById([rowIndex, nodeIndex]).className ===\n            \"node-wall\"\n        ) {\n          deleteWall(graph, rowIndex, nodeIndex);\n          document.getElementById([rowIndex, nodeIndex]).className = \"node\";\n        }\n      });\n    });\n  }\n\n  // clears the board of the search\n  clearSearch() {\n    const { graph } = this.state;\n    graph.forEach((row, rowIndex) => {\n      return row.forEach((node, nodeIndex) => {\n        if (\n          document.getElementById([rowIndex, nodeIndex]).className ===\n            \"node-shortest-path\" ||\n          document.getElementById([rowIndex, nodeIndex]).className ===\n            \"node-search\"\n        )\n          return (document.getElementById([rowIndex, nodeIndex]).className =\n            \"node\");\n      });\n    });\n  }\n\n  visualizeDijkstras() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const dijkstras = new Dijkstras(graph, startNode, endNode);\n      const { shortestPath, visitedNodes } = dijkstras.shortestPath();\n      animateSearchProcess(visitedNodes, shortestPath);\n    }\n  }\n\n  visualizeAStar() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const A_Star = new AStar(graph, startNode, endNode);\n      const { shortestPath, visitedNodes } = A_Star.shortestPath();\n      animateSearchProcess(visitedNodes, shortestPath);\n    }\n    return;\n  }\n\n  visualizeDFS() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const DFS = new DepthFirstSearch(graph, startNode, endNode);\n      const { path, visitedNodes } = DFS.search();\n      animateSearchProcess(visitedNodes, path);\n    }\n  }\n\n  visualizeBFS() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const BFS = new BreadthFirstSearch(graph, startNode, endNode);\n      const { path, visitedNodes } = BFS.search();\n      animateSearchProcess(visitedNodes, path);\n    }\n  }\n\n  visualizeGreedyBFS() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const GBFS = new GreedyBFS(graph, startNode, endNode);\n      const { shortestPath, visitedNodes } = GBFS.shortestPath();\n      animateSearchProcess(visitedNodes, shortestPath);\n    }\n  }\n\n  visualizeMaze() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const maze = new RecursiveBacktracking(graph, startNode, endNode);\n      createWalledGraph(graph, startNode, endNode);\n      setTimeout(() => animateMaze(maze.runMaze(), graph, endNode), 2000);\n    }\n  }\n  visualizeTree() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      const maze = new BinaryTreeMaze(graph, startNode, endNode);\n      createWalledGraph(graph, startNode, endNode);\n      setTimeout(() => animateMaze(maze.runMaze(), graph, endNode), 2000);\n    }\n  }\n\n  visualizeDivMaze() {\n    const { graph, startNode, endNode } = this.state;\n    if ((graph, startNode, endNode)) {\n      // reset field so we get a clear field\n      this.resetField();\n      const maze = new RecursiveDivision(graph, startNode, endNode);\n      animateDivMaze(maze.runMaze(), graph);\n    }\n  }\n\n  render() {\n    const { graph } = this.state;\n    // create the board.\n    let board = graph.map((row, rowIndex) => {\n      return (\n        // each row must be in a div so you can form a field in css\n        <div className=\"Row\" key={rowIndex}>\n          {row.map((node, nodeIndex) => {\n            // destructuring node object\n            const { row, column, wall, start, end } = node;\n            return (\n              <Node\n                key={nodeIndex}\n                row={row}\n                column={column}\n                wall={wall}\n                start={start}\n                end={end}\n                onMouseEnter={() => this.onMouseEnter(rowIndex, nodeIndex)}\n                onMouseDown={() => this.onMouseDown(rowIndex, nodeIndex)}\n                onMouseUp={() => this.onMouseUp(rowIndex, nodeIndex)}\n                onClick={() => this.onClick(rowIndex, nodeIndex)}\n              />\n            );\n          })}\n        </div>\n      );\n    });\n\n    //HTML\n    return (\n      <div className=\"Visualizer\">\n        <div className=\"Field\">{board}</div>\n        <ControlPanel\n          visualizeAStar={() => this.visualizeAStar()}\n          visualizeMaze={() => this.visualizeMaze()}\n          visualizeDijkstras={() => this.visualizeDijkstras()}\n          visualizeDivMaze={() => this.visualizeDivMaze()}\n          visualizeGreedyBFS={() => this.visualizeGreedyBFS()}\n          visualizeTree={() => this.visualizeTree()}\n          visualizeDFS={() => this.visualizeDFS()}\n          visualizeBFS={() => this.visualizeBFS()}\n          resetField={() => this.resetField()}\n          clearSearch={() => this.clearSearch()}\n        />\n      </div>\n    );\n  }\n}\n\nexport default Field;\n\nconst createGraph = (rowSize, colSize, isWall, isStart, isEnd, basecase) => {\n  const graph = [];\n  // create a 2D Array\n  for (let row = 0; row < rowSize; row++) {\n    const currentRow = [];\n    for (let column = 0; column < colSize; column++) {\n      // create an object with node coordinates. Starts and end return a true bool when they hit the coordinates\n      currentRow.push(\n        createNode(row, column, isWall, isStart, isEnd, basecase)\n      );\n    }\n    graph.push(currentRow);\n  }\n  return graph;\n};\n\nconst createNode = (row, column, isWall, isStart, isEnd, basecase) => {\n  const nodeSchema = {\n    row: row,\n    column: column,\n    wall: isWall,\n    start: isStart,\n    end: isEnd,\n  };\n  if (basecase === \"resetAll\")\n    document.getElementById([row, column]).className = \"node\";\n\n  return nodeSchema;\n};\n\nconst setStartNode = (graph, row, column) => {\n  graph[row][column].start = true;\n};\n\nconst deleteStartNode = (graph, row, column) => {\n  if (graph[row][column]) {\n    graph[row][column].start = false;\n  }\n};\n\nconst setEndNode = (graph, row, column) => {\n  graph[row][column].end = true;\n};\n\nconst deleteEndNode = (graph, row, column) => {\n  graph[row][column].end = false;\n};\n\nconst setWall = (graph, row, column) => {\n  graph[row][column].wall = true;\n  return graph;\n};\n\nconst deleteWall = (graph, row, column) => {\n  graph[row][column].wall = false;\n  return graph;\n};\n\nconst animateSearchProcess = (neighborList, shortestPath) => {\n  for (let i = 0; i < neighborList.length; i++) {\n    setTimeout(() => {\n      let currRow = neighborList[i][0];\n      let currColumn = neighborList[i][1];\n      document.getElementById([currRow, currColumn]).className = \"node-search\";\n      if (i === neighborList.length - 1) {\n        return setTimeout(() => {\n          animateShortestPath(shortestPath);\n        }, 150);\n      }\n    }, 30 * i);\n  }\n};\n\nconst animateShortestPath = (shortestPath) => {\n  for (let i = 0; i < shortestPath.length - 1; i++) {\n    setTimeout(() => {\n      let currRow = shortestPath[i][0];\n      let currColumn = shortestPath[i][1];\n      document.getElementById([currRow, currColumn]).className =\n        \"node-shortest-path\";\n    }, 60 * i);\n  }\n  return;\n};\n\nconst animateMaze = (wallList, graph, endNode, startNode) => {\n  // i = 1 so we dont animate start node\n  for (let i = 0; i < wallList.length; i++) {\n    setTimeout(() => {\n      const currRow = wallList[i][0];\n      const currColumn = wallList[i][1];\n      if (currRow !== endNode.row || currColumn !== endNode.column) {\n        deleteWall(graph, currRow, currColumn);\n        document.getElementById([currRow, currColumn]).className = \"node\";\n      }\n    }, 40 * i);\n  }\n};\n\nconst animateDivMaze = (wallList, graph) => {\n  // i = 1 so we dont animate start node\n  for (let i = 0; i < wallList.length; i++) {\n    setTimeout(() => {\n      const currRow = wallList[i][0];\n      const currColumn = wallList[i][1];\n      setWall(graph, currRow, currColumn);\n      document.getElementById([currRow, currColumn]).className = \"node-wall\";\n    }, 40 * i);\n  }\n};\n\nconst createWalledGraph = (graph, startNode, endNode) => {\n  setTimeout(() => {\n    graph.forEach((row, rowIndex) => {\n      return row.forEach((node, nodeIndex) => {\n        const currentNode = graph[rowIndex][nodeIndex];\n        if (!currentNode.start && !currentNode.end) {\n          setWall(graph, rowIndex, nodeIndex);\n          document.getElementById([rowIndex, nodeIndex]).className =\n            \"node-wall\";\n        }\n      });\n    });\n  });\n};\n","import React, { Component } from \"react\";\n// CSS\nimport \"./Navbar.css\";\n\nclass Navbar extends Component {\n  render() {\n    return (\n      <div>\n        <nav>\n          <label id=\"title\">Algorithm Visualizer</label>\n          <a href=\"https://github.com/Atska/visualizer\">\n            <div className=\"git-link\">Github</div>\n          </a>\n        </nav>\n      </div>\n    );\n  }\n}\n\nexport default Navbar;\n","import React from \"react\";\n//Components\nimport Visualizer from \"./components/Visualizer.js\";\nimport Navbar from \"./components/Navbar.js\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Navbar />\n      <Visualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}